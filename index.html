<!doctype html>
<html prefix="og: http://ogp.me/ns#">
<head>
	<meta name="generator" content="Hugo 0.156.0">
    <title>Simply Patrick</title>

  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta content="text/html; charset=UTF-8" http-equiv="Content-Type">

  <meta property="og:site_name" content="Simply Patrick"/>
  <meta property="og:url" content="https://blog.simplypatrick.com/"/>
  <meta property="og:type" content="website"/>
  <meta property="og:image" content="https://lh3.googleusercontent.com/-GqbL2_hPq9Y/UC9brHyHa1I/AAAAAAAAEoY/rGGtCNWe3Vw/s800/patrick.jpg"/>

  <link rel="preload" href="/fonts/Arvo-Regular.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/fonts/Julee-Regular.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/fonts/JustMeAgainDownHere-Regular.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/fonts/SourceCodePro-Regular.ttf" as="font" type="font/ttf" crossorigin>
<link rel="preload" href="/fonts/NotoSansTC-Regular.ttf" as="font" type="font/ttf" crossorigin>
<link href="//netdna.bootstrapcdn.com/bootstrap/3.1.1/css/bootstrap.min.css" rel="stylesheet">
<link href="/css/bootstrap-toc.css" rel="stylesheet">
<link href="//netdna.bootstrapcdn.com/font-awesome/4.0.3/css/font-awesome.css" rel="stylesheet">

<link href="/css/prism.css" rel="stylesheet" />
<link href="/css/blog.css" rel="stylesheet">

<link href="/images/favicon.ico" rel="shortcut icon" type="image/x-icon" />

</head>
<body>
    <div class="container" id="main">
    <div class="row">
      <header role="banner">
  <div class="row">
    <div class="col-md-9">
      <h1 class="banner-title">
        <a href="/">Simply Patrick</a>
        <small class="banner-subtitle">Hopes can always go up, tears can only come down.</small>
      </h1>
    </div>
    <div class="col-md-3 text-right">
      <ul class="social-links list-inline">
        <li><a href="https://twitter.com/PatrickSimply"><i class="fa fa-twitter"></i></a></li>
        <li><a href="https://www.facebook.com/yinghau76"><i class="fa fa-facebook"></i></a></li>
        <li><a href="https://www.linkedin.com/in/yinghau76"><i class="fa fa-linkedin"></i></a></li>
        <li><a href="https://github.com/p47t"><i class="fa fa-github-alt"></i></a></li>
      </ul>
    </div>
  <div>
</header>

      <nav class="navbar navbar-default" role="navigation">
  <div class="container-fluid">
    
    <div class="navbar-header">
      <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="/posts/">posts</a>
      <a class="navbar-brand" href="/tils/">TILs</a>
    </div>

    
    <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
      <ul class="nav navbar-nav">
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">categories <b class="caret"></b></a>
          <ul class="dropdown-menu">
          
            <li><a href="/categories/ai">ai <span class="badge">1</span></a></li>
          
            <li><a href="/categories/ai-assisted">ai-assisted <span class="badge">2</span></a></li>
          
            <li><a href="/categories/blog">blog <span class="badge">3</span></a></li>
          
            <li><a href="/categories/business">business <span class="badge">26</span></a></li>
          
            <li><a href="/categories/career">career <span class="badge">20</span></a></li>
          
            <li><a href="/categories/claude-code">claude-code <span class="badge">1</span></a></li>
          
            <li><a href="/categories/development">development <span class="badge">52</span></a></li>
          
            <li><a href="/categories/ffi">ffi <span class="badge">1</span></a></li>
          
            <li><a href="/categories/game">game <span class="badge">3</span></a></li>
          
            <li><a href="/categories/programming">programming <span class="badge">205</span></a></li>
          
            <li><a href="/categories/rust">rust <span class="badge">1</span></a></li>
          
            <li><a href="/categories/web">web <span class="badge">10</span></a></li>
          
            <li><a href="/categories/%e7%a1%ac%e9%ab%94">硬體 <span class="badge">1</span></a></li>
          
            <li><a href="/categories/%e9%96%8b%e7%99%bc%e5%b7%a5%e5%85%b7">開發工具 <span class="badge">1</span></a></li>
          
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">tags <b class="caret"></b></a>
          <ul class="dropdown-menu">
          
            <li><a href="/tags/agent">agent <span class="badge">4</span></a></li>
          
            <li><a href="/tags/agile">agile <span class="badge">4</span></a></li>
          
            <li><a href="/tags/ai">ai <span class="badge">2</span></a></li>
          
            <li><a href="/tags/ai-assisted">ai-assisted <span class="badge">13</span></a></li>
          
            <li><a href="/tags/android">android <span class="badge">14</span></a></li>
          
            <li><a href="/tags/async">async <span class="badge">2</span></a></li>
          
            <li><a href="/tags/audio">audio <span class="badge">1</span></a></li>
          
            <li><a href="/tags/ble">ble <span class="badge">1</span></a></li>
          
            <li><a href="/tags/book">book <span class="badge">25</span></a></li>
          
            <li><a href="/tags/build">build <span class="badge">4</span></a></li>
          
            <li><a href="/tags/build-tools">build-tools <span class="badge">1</span></a></li>
          
            <li><a href="/tags/builder">builder <span class="badge">1</span></a></li>
          
            <li><a href="/tags/c&#43;&#43;">c&#43;&#43; <span class="badge">8</span></a></li>
          
            <li><a href="/tags/cargo-apk">cargo-apk <span class="badge">1</span></a></li>
          
            <li><a href="/tags/claude">claude <span class="badge">1</span></a></li>
          
            <li><a href="/tags/claude-code">claude-code <span class="badge">4</span></a></li>
          
            <li><a href="/tags/cli">cli <span class="badge">2</span></a></li>
          
            <li><a href="/tags/cloud">cloud <span class="badge">1</span></a></li>
          
            <li><a href="/tags/codex">codex <span class="badge">1</span></a></li>
          
            <li><a href="/tags/crack">crack <span class="badge">2</span></a></li>
          
            <li><a href="/tags/derive">derive <span class="badge">1</span></a></li>
          
            <li><a href="/tags/design-patterns">design-patterns <span class="badge">4</span></a></li>
          
            <li><a href="/tags/dotnet">dotnet <span class="badge">42</span></a></li>
          
            <li><a href="/tags/dsp">dsp <span class="badge">1</span></a></li>
          
            <li><a href="/tags/embedded">embedded <span class="badge">5</span></a></li>
          
            <li><a href="/tags/engineer">engineer <span class="badge">2</span></a></li>
          
            <li><a href="/tags/ffi">ffi <span class="badge">1</span></a></li>
          
            <li><a href="/tags/ffmpeg">ffmpeg <span class="badge">1</span></a></li>
          
            <li><a href="/tags/font">font <span class="badge">3</span></a></li>
          
            <li><a href="/tags/fuchsia">fuchsia <span class="badge">2</span></a></li>
          
            <li><a href="/tags/futures">futures <span class="badge">2</span></a></li>
          
            <li><a href="/tags/game">game <span class="badge">2</span></a></li>
          
            <li><a href="/tags/git">git <span class="badge">5</span></a></li>
          
            <li><a href="/tags/go">go <span class="badge">5</span></a></li>
          
            <li><a href="/tags/google">google <span class="badge">5</span></a></li>
          
            <li><a href="/tags/gpu">gpu <span class="badge">1</span></a></li>
          
            <li><a href="/tags/gpui">gpui <span class="badge">2</span></a></li>
          
            <li><a href="/tags/gradle">gradle <span class="badge">1</span></a></li>
          
            <li><a href="/tags/gui">gui <span class="badge">4</span></a></li>
          
            <li><a href="/tags/hdr">hdr <span class="badge">1</span></a></li>
          
            <li><a href="/tags/iced">iced <span class="badge">2</span></a></li>
          
            <li><a href="/tags/image-processing">image-processing <span class="badge">2</span></a></li>
          
            <li><a href="/tags/ios">ios <span class="badge">6</span></a></li>
          
            <li><a href="/tags/java">java <span class="badge">9</span></a></li>
          
            <li><a href="/tags/jpeg">jpeg <span class="badge">1</span></a></li>
          
            <li><a href="/tags/jupyter">jupyter <span class="badge">1</span></a></li>
          
            <li><a href="/tags/keyboard">keyboard <span class="badge">1</span></a></li>
          
            <li><a href="/tags/kotlin">kotlin <span class="badge">2</span></a></li>
          
            <li><a href="/tags/kuso">kuso <span class="badge">3</span></a></li>
          
            <li><a href="/tags/management">management <span class="badge">3</span></a></li>
          
            <li><a href="/tags/markdown">markdown <span class="badge">1</span></a></li>
          
            <li><a href="/tags/mechanical-keyboard">mechanical-keyboard <span class="badge">1</span></a></li>
          
            <li><a href="/tags/microsoft">microsoft <span class="badge">14</span></a></li>
          
            <li><a href="/tags/ndk">ndk <span class="badge">1</span></a></li>
          
            <li><a href="/tags/octopress">octopress <span class="badge">3</span></a></li>
          
            <li><a href="/tags/ortholinear">ortholinear <span class="badge">1</span></a></li>
          
            <li><a href="/tags/osx">osx <span class="badge">4</span></a></li>
          
            <li><a href="/tags/parser">parser <span class="badge">1</span></a></li>
          
            <li><a href="/tags/patterns">patterns <span class="badge">4</span></a></li>
          
            <li><a href="/tags/peacock">peacock <span class="badge">1</span></a></li>
          
            <li><a href="/tags/proc-macro">proc-macro <span class="badge">1</span></a></li>
          
            <li><a href="/tags/process">process <span class="badge">2</span></a></li>
          
            <li><a href="/tags/productivity">productivity <span class="badge">1</span></a></li>
          
            <li><a href="/tags/qmk">qmk <span class="badge">1</span></a></li>
          
            <li><a href="/tags/ruby">ruby <span class="badge">15</span></a></li>
          
            <li><a href="/tags/rust">rust <span class="badge">23</span></a></li>
          
            <li><a href="/tags/scala">scala <span class="badge">3</span></a></li>
          
            <li><a href="/tags/shader">shader <span class="badge">1</span></a></li>
          
            <li><a href="/tags/slint">slint <span class="badge">1</span></a></li>
          
            <li><a href="/tags/spaced-repetition">spaced-repetition <span class="badge">1</span></a></li>
          
            <li><a href="/tags/startup">startup <span class="badge">3</span></a></li>
          
            <li><a href="/tags/swift">swift <span class="badge">1</span></a></li>
          
            <li><a href="/tags/traits">traits <span class="badge">1</span></a></li>
          
            <li><a href="/tags/tui">tui <span class="badge">1</span></a></li>
          
            <li><a href="/tags/ultrahdr">ultrahdr <span class="badge">2</span></a></li>
          
            <li><a href="/tags/vcs">vcs <span class="badge">3</span></a></li>
          
            <li><a href="/tags/vibe-coding">vibe-coding <span class="badge">1</span></a></li>
          
            <li><a href="/tags/vscode">vscode <span class="badge">1</span></a></li>
          
            <li><a href="/tags/wasm">wasm <span class="badge">5</span></a></li>
          
            <li><a href="/tags/web">web <span class="badge">3</span></a></li>
          
            <li><a href="/tags/webassembly">webassembly <span class="badge">3</span></a></li>
          
            <li><a href="/tags/webgpu">webgpu <span class="badge">1</span></a></li>
          
            <li><a href="/tags/webkit">webkit <span class="badge">3</span></a></li>
          
            <li><a href="/tags/wgpu">wgpu <span class="badge">1</span></a></li>
          
            <li><a href="/tags/windows">windows <span class="badge">5</span></a></li>
          
            <li><a href="/tags/work">work <span class="badge">11</span></a></li>
          
          </ul>
        </li>
        <li class="dropdown">
          <a href="#" class="dropdown-toggle" data-toggle="dropdown">series <b class="caret"></b></a>
          <ul class="dropdown-menu">
          
            <li><a href="/series/fuchsia-dev">fuchsia dev <span class="badge">2</span></a></li>
          
            <li><a href="/series/modern-c&#43;&#43;">modern c&#43;&#43; <span class="badge">2</span></a></li>
          
            <li><a href="/series/rust-52-projects">rust-52-projects <span class="badge">11</span></a></li>
          
            <li><a href="/series/zeroclaw">zeroclaw <span class="badge">4</span></a></li>
          
          </ul>
        </li>
      </ul>
      <form class="navbar-form navbar-left" role="search" action="/search/" method="get">
        <div class="form-group">
          <input class="form-control" type="text" name="q" results="0" placeholder="search"/>
        </div>
        <button type="submit" class="btn btn-default">submit</button>
      </form>
      <ul class="nav navbar-nav navbar-right">
        <li><a href="/pages/about">about</a></li>
      </ul>
    </div>
  </div>
</nav>

    </div>

  <div class="row">
    <div class="col-md-9">
      
      
                <span class="post-title">
          <a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-memory/" title="zeroclaw 如何設計 Memory 的抽象層">
            <h2>zeroclaw 如何設計 Memory 的抽象層</h2>
          </a>
        </span>
        <div class="post-meta">
          <span class="post-date">February 19, 2026</span>
          <a href="/tils/"><span class="label label-info">TIL</span></a>
          
          <a href="/tags/rust"><span class="label label-primary">rust</span></a>
          
          <a href="/tags/agent"><span class="label label-primary">agent</span></a>
          
          <a href="/tags/design-patterns"><span class="label label-primary">design-patterns</span></a>
          
        </div>
        <div class="post-content"><blockquote>
<p>zeroclaw 的 Memory 是 agent 的長期記憶——它記錄對話歷史、使用者偏好、決策紀錄，並在每次對話前把相關記憶召回注入給 LLM。這篇記錄它如何用一個 trait 統一四種後端（SQLite、Markdown、Lucid、Postgres），以及它最有趣的設計：混合式語意搜尋、Embedding LRU 快取、還有讓 agent 在冷啟動時從 Markdown 文字檔重建「靈魂」的機制。</p>
</blockquote>
<h2 id="memory-trait七個方法全部必填"><code>Memory</code> Trait：七個方法，全部必填</h2>
<p>跟 <a href="./2026-02-19-zeroclaw-channel.md">Channel</a> 和 <a href="./2026-02-19-zeroclaw-llm-provider.md">Provider</a> 的設計不同——後兩者都有預設實作——<code>Memory</code> trait 的七個方法<strong>全部是必填的</strong>：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Memory: Send <span style="color:#f92672">+</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">name</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">store</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        key: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>        content: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>        category: <span style="color:#a6e22e">MemoryCategory</span>,
</span></span><span style="display:flex;"><span>        session_id: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">recall</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        query: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>        limit: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>        session_id: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>MemoryEntry<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">get</span>(<span style="color:#f92672">&amp;</span>self, key: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>MemoryEntry<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">list</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        category: Option<span style="color:#f92672">&lt;&amp;</span>MemoryCategory<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        session_id: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>MemoryEntry<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">forget</span>(<span style="color:#f92672">&amp;</span>self, key: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">bool</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">count</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">usize</span><span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">health_check</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span>;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>這反映了「每種後端的搜尋策略都根本不同」——SQLite 用 FTS5 + 向量搜尋，Markdown 用關鍵字比對，Postgres 用 <code>ILIKE</code>——沒有一個合理的預設實作能套用在所有後端，所以索性不提供。</p>
<hr>
<h2 id="核心資料型別">核心資料型別</h2>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">MemoryEntry</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> id: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> key: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> content: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> category: <span style="color:#a6e22e">MemoryCategory</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> timestamp: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> session_id: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> score: Option<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f64</span><span style="color:#f92672">&gt;</span>,  <span style="color:#75715e">// 只有 recall() 會填，get()/list() 都是 None
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">MemoryCategory</span> {
</span></span><span style="display:flex;"><span>    Core,             <span style="color:#75715e">// 長期事實、偏好、決策
</span></span></span><span style="display:flex;"><span>    Daily,            <span style="color:#75715e">// 每日工作日誌
</span></span></span><span style="display:flex;"><span>    Conversation,     <span style="color:#75715e">// 對話上下文
</span></span></span><span style="display:flex;"><span>    Custom(String),   <span style="color:#75715e">// 開放式擴充點
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>score</code> 的設計很有趣：它是 <code>recall()</code> 的副產品，代表這筆記憶和查詢的相關度。<code>get()</code> 和 <code>list()</code> 都是精確查找，沒有「相關度」的概念，所以這個欄位在那兩個情境下永遠是 <code>None</code>。<code>Custom(String)</code> 則是一個逃生艙，讓使用者可以自訂任意分類而不需要修改 enum。</p>
<hr>
<h2 id="四個後端一個介面">四個後端，一個介面</h2>
<p>zeroclaw 目前有四個實作（加上一個 no-op）：</p>
<table>
  <thead>
      <tr>
          <th>後端</th>
          <th>搜尋方式</th>
          <th>特性</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>SqliteMemory</code></td>
          <td>FTS5 + 向量 (cosine)</td>
          <td>推薦預設，單一 <code>.db</code> 檔</td>
      </tr>
      <tr>
          <td><code>MarkdownMemory</code></td>
          <td>關鍵字比對</td>
          <td>純文字，只能追加</td>
      </tr>
      <tr>
          <td><code>LucidMemory</code></td>
          <td>SQLite + 外部 CLI</td>
          <td>橋接第三方記憶工具</td>
      </tr>
      <tr>
          <td><code>PostgresMemory</code></td>
          <td><code>ILIKE</code> 模糊比對</td>
          <td>雲端持久化，無 pgvector</td>
      </tr>
      <tr>
          <td><code>NoneMemory</code></td>
          <td>—</td>
          <td>完全 no-op，停用記憶</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="sqlite真正的大腦">SQLite：真正的大腦</h2>
<p><code>SqliteMemory</code> 是推薦的預設後端，資料存在 <code>workspace/memory/brain.db</code>。它的設計最複雜，也最值得細看。</p>
<h3 id="schema">Schema</h3>
<p>三張表，各有不同用途：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 主要記憶表
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> memories (
</span></span><span style="display:flex;"><span>    id         TEXT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">key</span>        TEXT <span style="color:#66d9ef">UNIQUE</span> <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,   <span style="color:#75715e">-- upsert 的 identity key
</span></span></span><span style="display:flex;"><span>    content    TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    category   TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span> <span style="color:#66d9ef">DEFAULT</span> <span style="color:#e6db74">&#39;core&#39;</span>,
</span></span><span style="display:flex;"><span>    embedding  BLOB,                   <span style="color:#75715e">-- f32 向量，little-endian bytes
</span></span></span><span style="display:flex;"><span>    created_at TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    updated_at TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    session_id TEXT
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- FTS5 全文搜尋虛擬表
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> VIRTUAL <span style="color:#66d9ef">TABLE</span> memories_fts <span style="color:#66d9ef">USING</span> fts5(
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">key</span>, content,
</span></span><span style="display:flex;"><span>    content<span style="color:#f92672">=</span>memories, content_rowid<span style="color:#f92672">=</span>rowid
</span></span><span style="display:flex;"><span>);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">-- Embedding LRU 快取
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">CREATE</span> <span style="color:#66d9ef">TABLE</span> embedding_cache (
</span></span><span style="display:flex;"><span>    content_hash TEXT <span style="color:#66d9ef">PRIMARY</span> <span style="color:#66d9ef">KEY</span>,  <span style="color:#75715e">-- SHA-256 前 16 hex chars
</span></span></span><span style="display:flex;"><span>    embedding    BLOB <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    created_at   TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>,
</span></span><span style="display:flex;"><span>    accessed_at  TEXT <span style="color:#66d9ef">NOT</span> <span style="color:#66d9ef">NULL</span>      <span style="color:#75715e">-- LRU 用
</span></span></span><span style="display:flex;"><span>);</span></span></code></pre></div>

<p>FTS5 透過三個 trigger（INSERT、DELETE、UPDATE）和主表保持同步。<code>store()</code> 用的是 <code>INSERT ... ON CONFLICT(key) DO UPDATE</code>——upsert 語意，<code>key</code> 是唯一識別碼，<code>id</code> 是 UUID（每次 upsert 都會更新）。</p>
<p>SQLite 開啟時的 PRAGMA 調校：WAL 模式、8 MB mmap、2 MB page cache、MEMORY temp store。</p>
<h3 id="為什麼用-spawn_blocking">為什麼用 <code>spawn_blocking</code>？</h3>
<p><code>rusqlite</code> 是 blocking API，直接在 async context 呼叫會卡住 tokio runtime。所有 SQLite 操作都包在 <code>tokio::task::spawn_blocking</code> 裡：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> tokio::task::spawn_blocking(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> conn <span style="color:#f92672">=</span> db.lock();
</span></span><span style="display:flex;"><span>    conn.execute(<span style="color:#e6db74">&#34;INSERT INTO memories ...&#34;</span>, <span style="color:#a6e22e">params!</span>[<span style="color:#f92672">..</span>.])<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    Ok(())
</span></span><span style="display:flex;"><span>}).<span style="color:#66d9ef">await</span><span style="color:#f92672">??</span>;</span></span></code></pre></div>

<p>連線的開啟還多了一層防護——用 worker thread + <code>mpsc::channel</code> 加上 <code>recv_timeout</code>，防止 SQLite 檔案被鎖住時永遠卡住：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> (tx, rx) <span style="color:#f92672">=</span> mpsc::channel();
</span></span><span style="display:flex;"><span>thread::spawn(<span style="color:#66d9ef">move</span> <span style="color:#f92672">||</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> _ <span style="color:#f92672">=</span> tx.send(Connection::open(<span style="color:#f92672">&amp;</span>path));
</span></span><span style="display:flex;"><span>});
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">match</span> rx.recv_timeout(Duration::from_secs(capped)) {
</span></span><span style="display:flex;"><span>    Ok(Ok(conn)) <span style="color:#f92672">=&gt;</span> conn,
</span></span><span style="display:flex;"><span>    Ok(Err(e)) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(e.into()),
</span></span><span style="display:flex;"><span>    Err(_) <span style="color:#f92672">=&gt;</span> <span style="color:#66d9ef">return</span> Err(<span style="color:#a6e22e">anyhow!</span>(<span style="color:#e6db74">&#34;SQLite open timed out&#34;</span>)),
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<hr>
<h2 id="混合語意搜尋fts5--向量">混合語意搜尋：FTS5 + 向量</h2>
<p><code>recall()</code> 的實作是整個記憶系統最有趣的部分。它不是單一的搜尋策略，而是三層 fallback：</p>

  <div class="mermaid">
    graph TD
    A["recall(query, limit)"] --> B{有設定 Embedding provider?}
    B -->|是| C[生成查詢向量]
    C --> D[FTS5 BM25 搜尋]
    D --> E["hybrid_merge(向量結果, 關鍵字結果)"]
    E --> F[回傳 Top-N]
    B -->|否| G[純 BM25 搜尋]
    G --> F
    D -->|FTS5 解析錯誤| H["LIKE %keyword% 兜底"]
    H --> F
  </div>

<h3 id="向量純-rust-cosine-similarity">向量：純 Rust Cosine Similarity</h3>
<p>向量以 <code>f32</code> little-endian bytes 存在 BLOB 欄位。Cosine similarity 是純 Rust 實作，刻意用 <code>f64</code> 累加以減少高維向量的浮點誤差：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">cosine_similarity</span>(a: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">f32</span>], b: <span style="color:#66d9ef">&amp;</span>[<span style="color:#66d9ef">f32</span>]) -&gt; <span style="color:#66d9ef">f32</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> dot <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0_</span><span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> norm_a <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0_</span><span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> norm_b <span style="color:#f92672">=</span> <span style="color:#ae81ff">0.0_</span><span style="color:#66d9ef">f64</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> (x, y) <span style="color:#66d9ef">in</span> a.iter().zip(b.iter()) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> x <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>::from(<span style="color:#f92672">*</span>x);
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> y <span style="color:#f92672">=</span> <span style="color:#66d9ef">f64</span>::from(<span style="color:#f92672">*</span>y);
</span></span><span style="display:flex;"><span>        dot <span style="color:#f92672">+=</span> x <span style="color:#f92672">*</span> y;
</span></span><span style="display:flex;"><span>        norm_a <span style="color:#f92672">+=</span> x <span style="color:#f92672">*</span> x;
</span></span><span style="display:flex;"><span>        norm_b <span style="color:#f92672">+=</span> y <span style="color:#f92672">*</span> y;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> denom <span style="color:#f92672">=</span> norm_a.sqrt() <span style="color:#f92672">*</span> norm_b.sqrt();
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>denom.is_finite() <span style="color:#f92672">||</span> denom <span style="color:#f92672">&lt;</span> <span style="color:#66d9ef">f64</span>::<span style="color:#66d9ef">EPSILON</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> <span style="color:#ae81ff">0.0</span>;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    (dot <span style="color:#f92672">/</span> denom).clamp(<span style="color:#ae81ff">0.0</span>, <span style="color:#ae81ff">1.0</span>) <span style="color:#66d9ef">as</span> <span style="color:#66d9ef">f32</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>這是暴力掃描所有有 embedding 的 row，沒有 ANN index（如 HNSW、IVFFlat）。對一個本地 agent 的記憶量來說夠用，不需要引入 pgvector 或外部向量 DB 的依賴。</p>
<h3 id="關鍵字fts5-bm25">關鍵字：FTS5 BM25</h3>
<p>查詢前先把每個 token 用雙引號包住再用 <code>OR</code> 連接，避免 FTS5 特殊字元造成解析錯誤：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> fts_query <span style="color:#f92672">=</span> query
</span></span><span style="display:flex;"><span>    .split_whitespace()
</span></span><span style="display:flex;"><span>    .map(<span style="color:#f92672">|</span>w<span style="color:#f92672">|</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">{w}</span><span style="color:#ae81ff">\&#34;</span><span style="color:#e6db74">&#34;</span>))
</span></span><span style="display:flex;"><span>    .collect::<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>_<span style="color:#f92672">&gt;&gt;</span>()
</span></span><span style="display:flex;"><span>    .join(<span style="color:#e6db74">&#34; OR &#34;</span>);</span></span></code></pre></div>

<p>FTS5 的 <code>bm25()</code> 分數是負數（越負越相關），取負後變成越大越好，和 cosine similarity 的方向統一。</p>
<h3 id="混合合併">混合合併</h3>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">hybrid_merge</span>(
</span></span><span style="display:flex;"><span>    vector_results: <span style="color:#66d9ef">&amp;</span>[(String, <span style="color:#66d9ef">f32</span>)],   <span style="color:#75715e">// (id, cosine)
</span></span></span><span style="display:flex;"><span>    keyword_results: <span style="color:#66d9ef">&amp;</span>[(String, <span style="color:#66d9ef">f32</span>)],  <span style="color:#75715e">// (id, -BM25)
</span></span></span><span style="display:flex;"><span>    vector_weight: <span style="color:#66d9ef">f32</span>,                 <span style="color:#75715e">// 預設 0.7
</span></span></span><span style="display:flex;"><span>    keyword_weight: <span style="color:#66d9ef">f32</span>,                <span style="color:#75715e">// 預設 0.3
</span></span></span><span style="display:flex;"><span>    limit: <span style="color:#66d9ef">usize</span>,
</span></span><span style="display:flex;"><span>) -&gt; Vec<span style="color:#f92672">&lt;</span>ScoredResult<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// BM25 分數正規化到 [0,1]
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// final_score = 0.7 * cosine + 0.3 * normalized_BM25
</span></span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 去重：HashMap keyed on id
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>合併後的 Top-N ID 用一次 <code>WHERE id IN (...)</code> 批次撈出，避免 N+1 query。</p>
<hr>
<h2 id="embedding-lru-快取">Embedding LRU 快取</h2>
<p>每次 <code>store()</code> 都需要為新內容生成 embedding，但相同的文字不應該重複打 API。快取的 key 是內容的 <strong>SHA-256 前 16 hex chars</strong>——明確選擇 SHA-256 而不是 <code>DefaultHasher</code>，因為後者的輸出在不同 Rust 版本之間不保證穩定。</p>
<p>LRU 淘汰不在 Rust 記憶體裡維護資料結構，而是直接在 SQL 裡做：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-sql" data-lang="sql"><span style="display:flex;"><span><span style="color:#75715e">-- 保留最新的 N 筆，刪除多餘的舊資料
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">DELETE</span> <span style="color:#66d9ef">FROM</span> embedding_cache <span style="color:#66d9ef">WHERE</span> content_hash <span style="color:#66d9ef">IN</span> (
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">SELECT</span> content_hash <span style="color:#66d9ef">FROM</span> embedding_cache
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">ORDER</span> <span style="color:#66d9ef">BY</span> accessed_at <span style="color:#66d9ef">ASC</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">LIMIT</span> <span style="color:#66d9ef">MAX</span>(<span style="color:#ae81ff">0</span>, (<span style="color:#66d9ef">SELECT</span> <span style="color:#66d9ef">COUNT</span>(<span style="color:#f92672">*</span>) <span style="color:#66d9ef">FROM</span> embedding_cache) <span style="color:#f92672">-</span> <span style="color:#f92672">?</span><span style="color:#ae81ff">1</span>)
</span></span><span style="display:flex;"><span>)</span></span></code></pre></div>

<p>這樣快取的淘汰邏輯完全不依賴記憶體狀態，重啟之後一樣有效。</p>
<hr>
<h2 id="embedding-provider">Embedding Provider</h2>
<p>Embedding 本身也是一個 trait：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> EmbeddingProvider: Send <span style="color:#f92672">+</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">name</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">dimensions</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">usize</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">embed</span>(<span style="color:#f92672">&amp;</span>self, texts: <span style="color:#66d9ef">&amp;</span>[<span style="color:#f92672">&amp;</span><span style="color:#66d9ef">str</span>]) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 唯一的預設方法：批次 embed 的單一版本
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">embed_one</span>(<span style="color:#f92672">&amp;</span>self, text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Vec<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">f32</span><span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> results <span style="color:#f92672">=</span> self.embed(<span style="color:#f92672">&amp;</span>[text]).<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>        results.pop().ok_or_else(<span style="color:#f92672">||</span> <span style="color:#a6e22e">anyhow!</span>(<span style="color:#e6db74">&#34;Empty embedding result&#34;</span>))
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>兩個具體實作：</p>
<ul>
<li><strong><code>NoopEmbedding</code></strong>：<code>dimensions() = 0</code>，回傳空向量。啟用後自動降級為純關鍵字搜尋。</li>
<li><strong><code>OpenAiEmbedding</code></strong>：打 <code>/v1/embeddings</code> endpoint。支援自訂 base URL，用 <code>custom:</code> 前綴指定：</li>
</ul>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">create_embedding_provider</span>(provider: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, api_key: <span style="color:#f92672">..</span>., model: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, dims: <span style="color:#66d9ef">usize</span>) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">match</span> provider {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;openai&#34;</span> <span style="color:#f92672">=&gt;</span> Box::new(OpenAiEmbedding::new(<span style="color:#e6db74">&#34;https://api.openai.com&#34;</span>, <span style="color:#f92672">..</span>.)),
</span></span><span style="display:flex;"><span>        name <span style="color:#66d9ef">if</span> name.starts_with(<span style="color:#e6db74">&#34;custom:&#34;</span>) <span style="color:#f92672">=&gt;</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">let</span> base_url <span style="color:#f92672">=</span> name.strip_prefix(<span style="color:#e6db74">&#34;custom:&#34;</span>).unwrap_or(<span style="color:#e6db74">&#34;&#34;</span>);
</span></span><span style="display:flex;"><span>            Box::new(OpenAiEmbedding::new(base_url, <span style="color:#f92672">..</span>.))  <span style="color:#75715e">// 指向 Ollama、本地推理伺服器等
</span></span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        _ <span style="color:#f92672">=&gt;</span> Box::new(NoopEmbedding),
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<hr>
<h2 id="markdownmemory只能追加的審計日誌">MarkdownMemory：只能追加的審計日誌</h2>
<p><code>MarkdownMemory</code> 的 <code>forget()</code> 永遠回傳 <code>false</code>——這個後端是<strong>只能追加的</strong>，設計上就是個審計日誌：</p>

  <pre tabindex="0"><code>workspace/MEMORY.md                  ← Core 類別
workspace/memory/2026-02-19.md       ← Daily 類別（按日期分檔）</code></pre>

<p>每次 <code>store()</code> 就在對應的 Markdown 檔尾端追加一行 <code>- **key**: content</code>。<code>recall()</code> 則是把查詢拆成關鍵字，計算每筆記憶裡出現了幾個，算出比例當作分數。</p>
<p>雖然搜尋能力差，但好處是人類可讀、可以直接用 Git 追蹤，也容易備份。</p>
<hr>
<h2 id="lucidmemory橋接外部-cli">LucidMemory：橋接外部 CLI</h2>
<p><code>LucidMemory</code> 是一個橋接層，SQLite 是主要儲存，外部 <code>lucid-memory</code> CLI 是輔助：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">LucidMemory</span> {
</span></span><span style="display:flex;"><span>    local: <span style="color:#a6e22e">SqliteMemory</span>,
</span></span><span style="display:flex;"><span>    recall_timeout: <span style="color:#a6e22e">Duration</span>,           <span style="color:#75715e">// 預設 500ms
</span></span></span><span style="display:flex;"><span>    store_timeout: <span style="color:#a6e22e">Duration</span>,            <span style="color:#75715e">// 預設 800ms
</span></span></span><span style="display:flex;"><span>    local_hit_threshold: <span style="color:#66d9ef">usize</span>,         <span style="color:#75715e">// 預設 3：本地結果夠多就不問 Lucid
</span></span></span><span style="display:flex;"><span>    failure_cooldown: <span style="color:#a6e22e">Duration</span>,         <span style="color:#75715e">// 任何錯誤後冷卻 15 秒
</span></span></span><span style="display:flex;"><span>    last_failure_at: <span style="color:#a6e22e">Mutex</span><span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>Instant<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>store()</code> 先寫 SQLite，再 fire-and-forget 同步到 Lucid。<code>recall()</code> 的策略：先問 SQLite，如果結果數量低於 <code>local_hit_threshold</code> 且 Lucid 不在冷卻期，才去呼叫 <code>lucid context &lt;query&gt;</code>，然後合併結果。</p>
<p>去重用的是一個 <code>NUL</code> 字元分隔的簽名：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">let</span> signature <span style="color:#f92672">=</span> <span style="color:#a6e22e">format!</span>(<span style="color:#e6db74">&#34;</span><span style="color:#e6db74">{}</span><span style="color:#ae81ff">\u{0}</span><span style="color:#e6db74">{}</span><span style="color:#e6db74">&#34;</span>, entry.key.to_lowercase(), entry.content.to_lowercase());</span></span></code></pre></div>

<p>Lucid 的輸出是自訂的 XML-like 格式：</p>

  <pre tabindex="0"><code>&lt;lucid-context&gt;
- [decision] Use token refresh middleware
- [context] Working in src/auth.rs
&lt;/lucid-context&gt;</code></pre>

<p>方括號裡的標籤（<code>decision</code>、<code>context</code>、<code>bug</code>、<code>learning</code>）會被映射回 <code>MemoryCategory</code>。</p>
<hr>
<h2 id="agent-的靈魂snapshot-與冷啟動恢復">Agent 的靈魂：Snapshot 與冷啟動恢復</h2>
<p>最讓我覺得有趣的設計是「靈魂快照」機制。</p>
<p>在每次記憶體清理（hygiene）時，如果啟用了 <code>snapshot_on_hygiene</code>，所有 <code>Core</code> 類別的記憶都會被 dump 到工作目錄的 <code>MEMORY_SNAPSHOT.md</code>。這個檔案是 Git 可追蹤的純文字。</p>
<p>更厲害的是<strong>冷啟動恢復</strong>：如果 <code>brain.db</code> 不存在（例如全新部署、或資料庫損毀刪除），但 <code>MEMORY_SNAPSHOT.md</code> 存在，factory 會在開啟後端之前先呼叫 <code>hydrate_from_snapshot()</code>，把 Markdown 裡的記憶逐筆還原回 SQLite。</p>

  <div class="mermaid">
    graph LR
    A["brain.db 存在?"] -->|是| B[正常開啟 SqliteMemory]
    A -->|否| C["MEMORY_SNAPSHOT.md 存在?"]
    C -->|是| D[hydrate_from_snapshot]
    D --> E[重新開啟 SqliteMemory]
    C -->|否| F[全新 SqliteMemory]
    B --> G[完成]
    E --> G
    F --> G
  </div>

<p>每次清理也會刪掉 <code>MemoryCategory::Conversation</code> 類別超過 <code>conversation_retention_days</code> 的舊紀錄——對話上下文是短暫的，不該無限累積。</p>
<hr>
<h2 id="在-agent-loop-裡的角色">在 Agent Loop 裡的角色</h2>
<p>Memory 在每輪對話的三個時機被使用：</p>

  <div class="mermaid">
    sequenceDiagram
    participant U as 使用者
    participant AL as Agent Loop
    participant M as Memory
    participant LLM as LLM

    U->>AL: 送出訊息
    AL->>M: recall(user_msg, 5)
    M-->>AL: 相關記憶（score >= 0.4 才納入）
    AL->>LLM: [Memory context]\n- key: content\n...\n{user_msg}
    LLM-->>AL: 回應
    AL->>M: store("user_msg_{uuid}", msg, Conversation)
    AL->>M: store("assistant_resp_{uuid}", summary[:100], Daily)
    AL-->>U: 最終答覆
  </div>

<p>注意幾個細節：</p>
<ul>
<li><strong>相關度門檻</strong>：<code>score &gt;= 0.4</code> 才注入，低分記憶不進 context，避免雜訊干擾 LLM。</li>
<li><strong>自動儲存</strong>：使用者訊息存 <code>Conversation</code> 類別（會被清理），助理回應只存前 100 字存 <code>Daily</code> 類別（會保留較久）。</li>
<li><strong>LLM 直接操控記憶</strong>：<code>memory_store</code>、<code>memory_recall</code>、<code>memory_forget</code> 這三個工具也被當成普通的 <code>Tool</code> 掛載到 agent 上，LLM 自己可以主動讀寫記憶。</li>
</ul>
<hr>
<h2 id="小結">小結</h2>
<p>zeroclaw Memory 設計幾個值得注意的地方：</p>
<ul>
<li><strong>全部必填，沒有預設</strong>：每種後端的搜尋策略差太多，預設實作沒有意義。</li>
<li><strong>SQLite 就夠用</strong>：FTS5 + 向量暴力搜尋在本地 agent 的規模不需要 pgvector，單一 <code>.db</code> 檔沒有外部依賴。</li>
<li><strong>三層 fallback 搜尋</strong>：Hybrid（FTS5 + 向量）→ BM25 only → <code>LIKE</code> 兜底，優雅降級。</li>
<li><strong>SHA-256 快取，LRU 在 SQL 裡做</strong>：快取邏輯不依賴記憶體狀態，重啟後仍然有效。</li>
<li><strong>靈魂快照</strong>：<code>MEMORY_SNAPSHOT.md</code> 是 Git 可追蹤的，讓 agent 可以從純文字重建長期記憶，冷啟動不代表失憶。</li>
<li><strong>Conversation 記憶會被清理</strong>：對話上下文是短暫的，設計上就不打算永久保留。</li>
</ul>
</div>

        <hr/>
      
                <span class="post-title">
          <a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-tools/" title="zeroclaw 如何設計 Tool 的抽象層">
            <h2>zeroclaw 如何設計 Tool 的抽象層</h2>
          </a>
        </span>
        <div class="post-meta">
          <span class="post-date">February 19, 2026</span>
          <a href="/tils/"><span class="label label-info">TIL</span></a>
          
          <a href="/tags/rust"><span class="label label-primary">rust</span></a>
          
          <a href="/tags/agent"><span class="label label-primary">agent</span></a>
          
          <a href="/tags/design-patterns"><span class="label label-primary">design-patterns</span></a>
          
        </div>
        <div class="post-content"><blockquote>
<p>zeroclaw 的 Tool 是 agent 採取行動的核心機制——執行 shell 指令、讀寫檔案、瀏覽網頁、呼叫 HTTP API、操作記憶體、甚至把任務委派給另一個 sub-agent。目前實作了 30+ 種工具。這篇記錄它如何用一個乾淨的 trait 統一所有工具，以及工具的組裝、dispatch、schema 正規化、安全注入等設計。</p>
</blockquote>
<h2 id="tool-trait四個必填一個免費"><code>Tool</code> Trait：四個必填，一個免費</h2>
<p>整個抽象的核心在 <code>src/tools/traits.rs</code>，只有四個方法是必須實作的：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Tool: Send <span style="color:#f92672">+</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">name</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">description</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parameters_schema</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">serde_json</span>::Value;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">serde_json</span>::Value) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>ToolResult<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 預設實作：把前三個方法組裝成 ToolSpec，免費附贈
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">spec</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">ToolSpec</span> {
</span></span><span style="display:flex;"><span>        ToolSpec {
</span></span><span style="display:flex;"><span>            name: <span style="color:#a6e22e">self</span>.name().to_string(),
</span></span><span style="display:flex;"><span>            description: <span style="color:#a6e22e">self</span>.description().to_string(),
</span></span><span style="display:flex;"><span>            parameters: <span style="color:#a6e22e">self</span>.parameters_schema(),
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>幾個設計決策值得注意：</p>
<ul>
<li><strong><code>Send + Sync</code></strong>：讓工具可以存進 <code>Arc&lt;dyn Tool&gt;</code> 並在 thread 之間共享，必要條件。</li>
<li><strong><code>async fn execute</code></strong>：所有工具都可能有 I/O，統一用 async，不需要區分同步/非同步工具。</li>
<li><strong>參數是 <code>serde_json::Value</code></strong>：不是每個工具一個強型別 struct，而是執行時從 JSON 取值。省去了大量 boilerplate，代價是錯誤在執行時才出現，而不是編譯時。</li>
<li><strong><code>spec()</code> 是預設方法</strong>：把 <code>name</code>、<code>description</code>、<code>parameters_schema</code> 這三個方法的結果組裝成 <code>ToolSpec</code>，新增工具完全不需要自己實作這個。</li>
</ul>
<hr>
<h2 id="核心資料型別">核心資料型別</h2>
<p>三個關鍵型別：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 每次執行的回傳值
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToolResult</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> success: <span style="color:#66d9ef">bool</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> output: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> error: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 送給 LLM 描述「這個工具能做什麼」的規格書
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToolSpec</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> name: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> description: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> parameters: <span style="color:#a6e22e">serde_json</span>::Value,  <span style="color:#75715e">// JSON Schema 物件
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>注意 <code>execute</code> 的錯誤處理設計：<strong>正常的執行失敗</strong>（找不到檔案、路徑不允許）用 <code>ToolResult { success: false, error: Some(...) }</code> 回傳；只有程式本身的 bug 或不可恢復的錯誤才回傳 <code>anyhow::Result::Err</code>。這讓 agent loop 可以把執行失敗的結果繼續送給 LLM 讓它決定下一步，而不是直接炸掉整個流程。</p>
<p>參數 schema 是用 <code>serde_json::json!()</code> 手寫 JSON Schema，沒有 proc macro 或 derive：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parameters_schema</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">serde_json</span>::Value {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">json!</span>({
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;object&#34;</span>,
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;properties&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;command&#34;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;The shell command to execute&#34;</span>
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;approved&#34;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;boolean&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;Set true to explicitly approve medium/high-risk commands&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;default&#34;</span>: <span style="color:#a6e22e">false</span>
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        },
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;required&#34;</span>: [<span style="color:#e6db74">&#34;command&#34;</span>]
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<hr>
<h2 id="工具的組裝工廠函式不靠反射">工具的組裝：工廠函式，不靠反射</h2>
<p>工具不是自動發現的，而是在 <code>src/tools/mod.rs</code> 裡用工廠函式顯式組裝：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 最小集合，給測試和簡單 agent 用
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">default_tools</span>(security: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>SecurityPolicy<span style="color:#f92672">&gt;</span>) -&gt; Vec<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">vec!</span>[
</span></span><span style="display:flex;"><span>        Box::new(ShellTool::new(security.clone(), runtime)),
</span></span><span style="display:flex;"><span>        Box::new(FileReadTool::new(security.clone())),
</span></span><span style="display:flex;"><span>        Box::new(FileWriteTool::new(security)),
</span></span><span style="display:flex;"><span>    ]
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 完整工具集，根據設定條件啟用
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">all_tools_with_runtime</span>(config, security, runtime, memory, <span style="color:#f92672">..</span>.) -&gt; Vec<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> tools: Vec<span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;&gt;</span> <span style="color:#f92672">=</span> <span style="color:#a6e22e">vec!</span>[
</span></span><span style="display:flex;"><span>        Box::new(ShellTool::new(<span style="color:#f92672">..</span>.)),
</span></span><span style="display:flex;"><span>        Box::new(FileReadTool::new(<span style="color:#f92672">..</span>.)),
</span></span><span style="display:flex;"><span>        Box::new(CronAddTool::new(<span style="color:#f92672">..</span>.)),
</span></span><span style="display:flex;"><span>        Box::new(MemoryStoreTool::new(<span style="color:#f92672">..</span>.)),
</span></span><span style="display:flex;"><span>        <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span>    ];
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 條件啟用：設定決定工具集，不是全部預設開啟
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> browser_config.enabled {
</span></span><span style="display:flex;"><span>        tools.push(Box::new(BrowserTool::new_with_backend(<span style="color:#f92672">..</span>.)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> http_config.enabled {
</span></span><span style="display:flex;"><span>        tools.push(Box::new(HttpRequestTool::new(<span style="color:#f92672">..</span>.)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>agents.is_empty() {
</span></span><span style="display:flex;"><span>        tools.push(Box::new(DelegateTool::new(agents, <span style="color:#f92672">..</span>.)));
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    tools
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>這是<strong>工廠/建構器模式</strong>——沒有反射、沒有 <code>inventory</code> 這類 compile-time 自動收集 crate、沒有 <code>#[register_tool]</code> 巨集。好處是依賴關係一目了然，壞處是每加一個工具都要手動登記。對這個規模的 codebase 來說是對的取捨。</p>
<hr>
<h2 id="兩種-dispatch-模式">兩種 Dispatch 模式</h2>
<p>工具的呼叫有兩條路，取決於 LLM provider 是否支援原生 function calling：</p>

  <div class="mermaid">
    graph TD
    A[LLM 回應] --> B{支援原生 Tool Calling?}
    B -->|是| C[NativeToolDispatcher]
    B -->|否| D[XmlToolDispatcher]
    C -->|解析 API 的 tool_calls 欄位| E[ParsedToolCall]
    D -->|解析文字裡的 XML tag| E
    E --> F["find_tool(name)"]
    F --> G["tool.execute(args)"]
    G --> H[ToolResult]
    H --> I[轉成 ConversationMessage]
    I --> J[送回 LLM 繼續下一輪]
  </div>

<p><code>NativeToolDispatcher</code> 用於 Anthropic、OpenAI、Gemini——這些 provider 會在 API response 裡回傳結構化的工具呼叫，直接解析即可。</p>
<p><code>XmlToolDispatcher</code> 用於不支援原生 function calling 的 LLM。此時 zeroclaw 把工具的說明注入到 system prompt，要求 LLM 用特定格式回應：</p>

  <pre tabindex="0"><code>&lt;tool_call&gt;{&#34;name&#34;: &#34;shell&#34;, &#34;arguments&#34;: {&#34;command&#34;: &#34;ls -la&#34;}}&lt;/tool_call&gt;</code></pre>

<p>然後用字串解析從回應文字裡抓出這些 XML tag。</p>
<p>Agent loop 查找工具的方式很簡單：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">find_tool</span><span style="color:#f92672">&lt;</span><span style="color:#a6e22e">&#39;a</span><span style="color:#f92672">&gt;</span>(tools: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">&#39;a</span> [Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;</span>], name: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#a6e22e">&#39;a</span> <span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    tools.iter().find(<span style="color:#f92672">|</span>t<span style="color:#f92672">|</span> t.name() <span style="color:#f92672">==</span> name).map(<span style="color:#f92672">|</span>t<span style="color:#f92672">|</span> t.as_ref())
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>送給 LLM 的格式（以 OpenAI 為例）：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">tools_to_openai_format</span>(tools: <span style="color:#66d9ef">&amp;</span>[Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Tool<span style="color:#f92672">&gt;</span>]) -&gt; Vec<span style="color:#f92672">&lt;</span>serde_json::Value<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    tools.iter().map(<span style="color:#f92672">|</span>tool<span style="color:#f92672">|</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#a6e22e">json!</span>({
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;function&#34;</span>,
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;function&#34;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;name&#34;</span>: <span style="color:#a6e22e">tool</span>.name(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;description&#34;</span>: <span style="color:#a6e22e">tool</span>.description(),
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;parameters&#34;</span>: <span style="color:#a6e22e">tool</span>.parameters_schema()
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }).collect()
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<hr>
<h2 id="json-schema-的跨-provider-正規化">JSON Schema 的跨 Provider 正規化</h2>
<p>各家 LLM API 對 JSON Schema 的支援程度差異很大，尤其是 Gemini——它會拒絕很多標準的 JSON Schema 關鍵字。<code>src/tools/schema.rs</code> 的 <code>SchemaCleanr</code> 專門處理這件事：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">CleaningStrategy</span> {
</span></span><span style="display:flex;"><span>    Gemini,       <span style="color:#75715e">// 最嚴格
</span></span></span><span style="display:flex;"><span>    Anthropic,
</span></span><span style="display:flex;"><span>    OpenAI,       <span style="color:#75715e">// 最寬鬆
</span></span></span><span style="display:flex;"><span>    Conservative, <span style="color:#75715e">// 保守策略，適合未知 provider
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SchemaCleanr</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> SchemaCleanr {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clean_for_gemini</span>(schema: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clean_for_anthropic</span>(schema: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">clean_for_openai</span>(schema: <span style="color:#a6e22e">Value</span>) -&gt; <span style="color:#a6e22e">Value</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>各策略的主要差異：</p>
<table>
  <thead>
      <tr>
          <th>關鍵字</th>
          <th>Gemini</th>
          <th>Anthropic</th>
          <th>OpenAI</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td><code>minLength</code>、<code>pattern</code></td>
          <td>移除</td>
          <td>移除</td>
          <td>保留</td>
      </tr>
      <tr>
          <td><code>$ref</code></td>
          <td>內聯展開</td>
          <td>內聯展開</td>
          <td>保留</td>
      </tr>
      <tr>
          <td><code>additionalProperties</code></td>
          <td>移除</td>
          <td>保留</td>
          <td>保留</td>
      </tr>
      <tr>
          <td><code>anyOf</code>/<code>oneOf</code></td>
          <td>攤平為第一個型別</td>
          <td>保留</td>
          <td>保留</td>
      </tr>
      <tr>
          <td><code>nullable</code></td>
          <td>轉換格式</td>
          <td>保留</td>
          <td>保留</td>
      </tr>
  </tbody>
</table>
<p>Gemini 甚至連 <code>anyOf: [type: string, type: null]</code>（nullable 的常見寫法）都要特別轉換。這些邊緣情況全部藏在 <code>SchemaCleanr</code> 裡，工具本身完全不需要知道。</p>
<hr>
<h2 id="安全性是注入的不是全域的">安全性是注入的，不是全域的</h2>
<p>zeroclaw 的安全設計有個核心原則：<strong>安全策略是建構時注入的，不是全域的靜態狀態</strong>。</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 每個有 I/O 的工具都在建構時收到 SecurityPolicy
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">FileReadTool</span> {
</span></span><span style="display:flex;"><span>    security: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>SecurityPolicy<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ShellTool</span> {
</span></span><span style="display:flex;"><span>    security: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>SecurityPolicy<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    runtime: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> RuntimeAdapter<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">serde_json</span>::Value) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>ToolResult<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> path <span style="color:#f92672">=</span> args.get(<span style="color:#e6db74">&#34;path&#34;</span>).and_then(<span style="color:#f92672">|</span>v<span style="color:#f92672">|</span> v.as_str())<span style="color:#f92672">..</span>.;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 安全檢查在 execute 裡，繞不過去
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#f92672">!</span>self.security.is_path_allowed(path) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Ok(ToolResult { success: <span style="color:#a6e22e">false</span>, error: Some(<span style="color:#e6db74">&#34;Path not allowed&#34;</span>.into()), <span style="color:#f92672">..</span>. });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 繼續執行...
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>SecurityPolicy</code> 強制執行工作區沙盒（防止讀寫工作目錄以外的路徑）、自主等級（ReadOnly、Supervised、Full）、rate limiting 和指令白名單。</p>
<p>Supervised 模式下還有 <code>ApprovalManager</code>，在執行高風險工具前暫停等待使用者確認：</p>

  <pre tabindex="0"><code>[zeroclaw] Tool: shell
Command: rm -rf /tmp/build
[y]es / [n]o / [a]lways: _</code></pre>

<p>選 <code>always</code> 之後，這個指令會被加進 session allowlist，下次遇到同樣的指令就不再詢問。</p>
<hr>
<h2 id="有趣的具體工具">有趣的具體工具</h2>
<h3 id="delegatetool動態-schema-的工具">DelegateTool：動態 Schema 的工具</h3>
<p><code>DelegateTool</code> 是最有趣的工具之一——它的 <code>parameters_schema()</code> 是<strong>執行時動態生成</strong>的，而不是靜態寫死的：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">DelegateTool</span> {
</span></span><span style="display:flex;"><span>    agents: <span style="color:#a6e22e">Arc</span><span style="color:#f92672">&lt;</span>HashMap<span style="color:#f92672">&lt;</span>String, DelegateAgentConfig<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>    depth: <span style="color:#66d9ef">u32</span>,  <span style="color:#75715e">// 防止無限委派遞迴
</span></span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">parameters_schema</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">serde_json</span>::Value {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 根據目前設定的 agent 列表動態生成 schema
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> agent_names: Vec<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span> <span style="color:#f92672">=</span> self.agents.keys().map(<span style="color:#f92672">|</span>s<span style="color:#f92672">|</span> s.as_str()).collect();
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">json!</span>({
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;properties&#34;</span>: {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;agent&#34;</span>: {
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>,
</span></span><span style="display:flex;"><span>                <span style="color:#e6db74">&#34;description&#34;</span>: <span style="color:#a6e22e">format</span><span style="color:#f92672">!</span>(<span style="color:#e6db74">&#34;Which agent to delegate to. Available: {}&#34;</span>,
</span></span><span style="display:flex;"><span>                                       agent_names.join(<span style="color:#e6db74">&#34;, &#34;</span>))
</span></span><span style="display:flex;"><span>            },
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;task&#34;</span>: { <span style="color:#e6db74">&#34;type&#34;</span>: <span style="color:#e6db74">&#34;string&#34;</span>, <span style="color:#e6db74">&#34;description&#34;</span>: <span style="color:#e6db74">&#34;Task description for the agent&#34;</span> }
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    })
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">serde_json</span>::Value) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>ToolResult<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> self.depth <span style="color:#f92672">&gt;=</span> <span style="color:#66d9ef">MAX_DELEGATION_DEPTH</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> Ok(ToolResult { success: <span style="color:#a6e22e">false</span>, error: Some(<span style="color:#e6db74">&#34;Max delegation depth reached&#34;</span>), <span style="color:#f92672">..</span>. });
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> provider <span style="color:#f92672">=</span> create_provider(<span style="color:#f92672">&amp;</span>agent_config.provider, <span style="color:#f92672">..</span>.)<span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 120 秒 timeout，防止 sub-agent 跑太久
</span></span></span><span style="display:flex;"><span>    tokio::time::timeout(Duration::from_secs(<span style="color:#ae81ff">120</span>),
</span></span><span style="display:flex;"><span>        provider.chat_with_system(<span style="color:#f92672">..</span>.)).<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>depth</code> 欄位防止 agent A 委派給 agent B、B 又委派回 A 的無限迴圈。</p>
<h3 id="shelltool乾淨的執行環境">ShellTool：乾淨的執行環境</h3>
<p><code>ShellTool</code> 的安全設計很謹慎——它<strong>清空整個環境變數</strong>，只保留一個安全白名單：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">execute</span>(<span style="color:#f92672">&amp;</span>self, args: <span style="color:#a6e22e">serde_json</span>::Value) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>ToolResult<span style="color:#f92672">&gt;</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 清除所有環境變數，防止 API key 洩漏給子行程
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> <span style="color:#66d9ef">mut</span> cmd <span style="color:#f92672">=</span> Command::new(<span style="color:#e6db74">&#34;sh&#34;</span>);
</span></span><span style="display:flex;"><span>    cmd.env_clear();  <span style="color:#75715e">// 全部清空
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">for</span> key <span style="color:#66d9ef">in</span> <span style="color:#66d9ef">SAFE_ENV_VARS</span> {  <span style="color:#75715e">// 只加回白名單裡的
</span></span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Ok(val) <span style="color:#f92672">=</span> std::env::var(key) {
</span></span><span style="display:flex;"><span>            cmd.env(key, val);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 60 秒 timeout，截斷輸出到 1MB
</span></span></span><span style="display:flex;"><span>    tokio::time::timeout(Duration::from_secs(<span style="color:#ae81ff">60</span>), cmd.output()).<span style="color:#66d9ef">await</span>
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>SAFE_ENV_VARS</code> 包含 <code>PATH</code>、<code>HOME</code>、<code>LANG</code> 這類系統必要的變數，但不包含任何 <code>*_API_KEY</code>、<code>*_SECRET</code> 這類敏感變數。即使主行程有這些環境變數，子行程也看不到。</p>
<hr>
<h2 id="完整的-tool-call-流程">完整的 Tool Call 流程</h2>

  <div class="mermaid">
    sequenceDiagram
    participant U as 使用者
    participant AL as Agent Loop
    participant P as Provider
    participant LLM as LLM API
    participant T as Tool

    U->>AL: 送出訊息
    AL->>P: tools_to_provider_format(specs)
    P->>LLM: chat request + tool definitions
    LLM-->>P: 回應（含 tool calls）
    P-->>AL: ChatResponse { tool_calls: [...] }
    loop 最多 10 次
        AL->>AL: find_tool(name)
        AL->>AL: ApprovalManager（Supervised 模式）
        AL->>T: execute(args)
        T->>T: SecurityPolicy 檢查
        T-->>AL: ToolResult
        AL->>P: 把結果轉成 ConversationMessage
        P->>LLM: 繼續對話（含工具執行結果）
        LLM-->>P: 新回應
        alt 不再呼叫工具
            P-->>AL: 純文字回應
            AL-->>U: 最終答覆
        end
    end
  </div>

<p>整個流程最多迴圈 10 次（<code>DEFAULT_MAX_TOOL_ITERATIONS</code>）。超過就強制停止，防止 agent 無止境地呼叫工具。</p>
<hr>
<h2 id="小結">小結</h2>
<p>zeroclaw 的 Tool 設計幾個值得借鑑的地方：</p>
<ul>
<li><strong>最小介面</strong>：四個必填方法，<code>spec()</code> 是免費的預設實作，新增工具的門檻很低。</li>
<li><strong>工廠函式，不靠反射</strong>：顯式組裝、條件啟用，依賴關係清晰，沒有魔法。</li>
<li><strong>兩種 Dispatch 兼顧</strong>：原生 API tool calling 和 XML prompt 注入都支援，對各種 LLM 都能用。</li>
<li><strong>Schema 正規化是一等公民</strong>：<code>SchemaCleanr</code> 把各家 API 的奇葩限制集中處理，工具本身不受污染。</li>
<li><strong>安全是建構時注入的</strong>：<code>SecurityPolicy</code> 在 <code>new()</code> 時就進去了，不是全域狀態，也無法繞過。</li>
<li><strong>執行失敗不等於程式崩潰</strong>：<code>ToolResult { success: false }</code> 讓 agent 可以從失敗中學習，繼續嘗試。</li>
</ul>
</div>

        <hr/>
      
                <span class="post-title">
          <a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-channel/" title="zeroclaw 如何設計 Channel 的抽象層">
            <h2>zeroclaw 如何設計 Channel 的抽象層</h2>
          </a>
        </span>
        <div class="post-meta">
          <span class="post-date">February 19, 2026</span>
          <a href="/tils/"><span class="label label-info">TIL</span></a>
          
          <a href="/tags/rust"><span class="label label-primary">rust</span></a>
          
          <a href="/tags/agent"><span class="label label-primary">agent</span></a>
          
          <a href="/tags/design-patterns"><span class="label label-primary">design-patterns</span></a>
          
        </div>
        <div class="post-content"><blockquote>
<p>zeroclaw 的 Channel 負責接收與傳送訊息，支援 Telegram、Discord、Slack、Matrix、iMessage、Signal、IRC、Email 等 14 種平台。這篇記錄它如何用一個乾淨的 trait 把這些平台統一起來，以及 runtime 如何把訊息分派給 LLM 處理。</p>
</blockquote>
<h2 id="trait-設計三個必填其餘自選">Trait 設計：三個必填，其餘自選</h2>
<p><code>Channel</code> trait 定義在 <code>src/channels/traits.rs</code>，只有三個方法是必須實作的：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Channel: Send <span style="color:#f92672">+</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">name</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send</span>(<span style="color:#f92672">&amp;</span>self, message: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">SendMessage</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">listen</span>(<span style="color:#f92672">&amp;</span>self, tx: <span style="color:#a6e22e">tokio</span>::sync::mpsc::Sender<span style="color:#f92672">&lt;</span>ChannelMessage<span style="color:#f92672">&gt;</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 以下都有預設空實作（no-op）
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">health_check</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">true</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">start_typing</span>(<span style="color:#f92672">&amp;</span>self, _recipient: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> { Ok(()) }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">stop_typing</span>(<span style="color:#f92672">&amp;</span>self, _recipient: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> { Ok(()) }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 串流草稿更新（目前只有 Telegram 實作）
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">supports_draft_updates</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#66d9ef">bool</span> { <span style="color:#66d9ef">false</span> }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">send_draft</span>(<span style="color:#f92672">&amp;</span>self, _message: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">SendMessage</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span> { Ok(None) }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">update_draft</span>(<span style="color:#f92672">&amp;</span>self, _recipient: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, _message_id: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, _text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> { Ok(()) }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">finalize_draft</span>(<span style="color:#f92672">&amp;</span>self, _recipient: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, _message_id: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, _text: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>()<span style="color:#f92672">&gt;</span> { Ok(()) }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>最有趣的是 <code>listen</code> 的簽名：它拿到一個 <code>mpsc::Sender&lt;ChannelMessage&gt;</code>，然後把收到的訊息<strong>推進去</strong>——而不是回呼（callback）。這是 push-based observer pattern，讓所有平台的訊息都匯聚到同一條 mpsc 管道，runtime 只需要從一個地方消費。</p>
<hr>
<h2 id="訊息型別">訊息型別</h2>
<p>進來的訊息（<code>ChannelMessage</code>）和出去的訊息（<code>SendMessage</code>）分開定義：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ChannelMessage</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> id: String,           <span style="color:#75715e">// 去重用的 ID
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> sender: String,       <span style="color:#75715e">// 發送者識別碼
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> reply_target: String, <span style="color:#75715e">// 要回覆的目標（chat_id、channel_id 等）
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> content: String,      <span style="color:#75715e">// 正規化後的純文字內容
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> channel: String,      <span style="color:#75715e">// &#34;telegram&#34; | &#34;discord&#34; | &#34;slack&#34; | ...
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> timestamp: <span style="color:#66d9ef">u64</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">SendMessage</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> content: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> recipient: String,        <span style="color:#75715e">// 平台專屬的目標識別碼
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> subject: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,  <span style="color:#75715e">// Email 用的主旨
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>各平台的 sender/reply_target 格式天差地別（Telegram 是數字 chat_id、Discord 是 snowflake ID、Email 是郵件地址），但對上層 runtime 來說一律是字串，不需要知道細節。</p>
<hr>
<h2 id="14-個平台一個介面">14 個平台，一個介面</h2>
<p><code>src/channels/mod.rs</code> 列出了目前支援的所有 channel：</p>
<table>
  <thead>
      <tr>
          <th>分類</th>
          <th>平台</th>
          <th>底層協議</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>終端</td>
          <td>CLI</td>
          <td>stdin/stdout</td>
      </tr>
      <tr>
          <td>即時通訊</td>
          <td>Telegram</td>
          <td>HTTP long-polling</td>
      </tr>
      <tr>
          <td></td>
          <td>Discord</td>
          <td>WebSocket Gateway</td>
      </tr>
      <tr>
          <td></td>
          <td>Slack</td>
          <td>HTTP polling</td>
      </tr>
      <tr>
          <td></td>
          <td>Mattermost</td>
          <td>WebSocket / HTTP</td>
      </tr>
      <tr>
          <td></td>
          <td>WhatsApp</td>
          <td>Meta Cloud API webhook</td>
      </tr>
      <tr>
          <td></td>
          <td>iMessage</td>
          <td>macOS <code>osascript</code></td>
      </tr>
      <tr>
          <td></td>
          <td>Matrix</td>
          <td>matrix-sdk 同步</td>
      </tr>
      <tr>
          <td></td>
          <td>Signal</td>
          <td>signal-cli HTTP daemon</td>
      </tr>
      <tr>
          <td></td>
          <td>IRC</td>
          <td>TCP/TLS</td>
      </tr>
      <tr>
          <td>企業通訊</td>
          <td>Lark/Feishu</td>
          <td>WebSocket + Protobuf</td>
      </tr>
      <tr>
          <td></td>
          <td>DingTalk</td>
          <td>WebSocket</td>
      </tr>
      <tr>
          <td></td>
          <td>QQ</td>
          <td>HTTP API</td>
      </tr>
      <tr>
          <td>電子郵件</td>
          <td>Email</td>
          <td>SMTP + IMAP</td>
      </tr>
  </tbody>
</table>
<p>每個 channel 一個 struct，實作 <code>Channel</code> trait，差異只在各自的 struct 欄位和協議處理。</p>
<hr>
<h2 id="有趣的實作細節">有趣的實作細節</h2>
<h3 id="discord手刻-gateway-websocket">Discord：手刻 Gateway WebSocket</h3>
<p>Discord 沒有用任何 Discord SDK，而是用 <code>tokio-tungstenite</code> 手刻了整個 Gateway 協議：</p>
<ol>
<li>先打 REST 拿 Gateway URL</li>
<li>建立 WebSocket 連線</li>
<li>走完 <code>Hello → Identify → READY</code> 握手流程</li>
<li>另開一個 task 發心跳（heartbeat）</li>
<li>處理各種 opcode：1（心跳請求）、7（重連）、9（session 失效）</li>
</ol>
<p>這樣做的好處是二進位體積可控、依賴少，但代價是要自己維護協議細節。</p>
<h3 id="telegram串流草稿更新">Telegram：串流草稿更新</h3>
<p>Telegram 是唯一實作 <code>supports_draft_updates()</code> 的 channel，可以做到「LLM 邊生成邊更新訊息」的效果：</p>

  <div class="mermaid">
    sequenceDiagram
    participant U as 使用者
    participant TG as Telegram
    participant A as Agent
    participant LLM as LLM

    U->>TG: 送出訊息
    TG->>A: ChannelMessage
    A->>TG: send_draft("...") → message_id
    A->>+LLM: 串流請求
    loop 每隔 N ms
        LLM-->>A: delta token
        A->>TG: update_draft(message_id, 累積文字)
        Note over TG,U: 使用者看到訊息逐漸變長
    end
    LLM-->>-A: 生成完畢
    A->>TG: finalize_draft(message_id, 最終格式)
  </div>

<p>這個效果類似 ChatGPT 網頁版的逐字輸出，但是在 Telegram 上實現。</p>
<h3 id="larkfeishuprotobuf-frame">Lark/Feishu：Protobuf Frame</h3>
<p>Lark 的 WebSocket 協議不是 JSON，而是用 <code>prost</code>（Rust 的 protobuf 實作）解析自訂的 <code>PbFrame</code> 格式，區分 <code>method=0</code>（ping/pong）和 <code>method=1</code>（實際事件）。是這 14 個 channel 裡協議最複雜的一個。</p>
<hr>
<h2 id="runtime把一切串起來">Runtime：把一切串起來</h2>
<p>所有 channel 都跑起來之後，<code>start_channels()</code> 做的事情：</p>
<ol>
<li><strong>一條共用 mpsc</strong>：所有 channel 的 <code>listen</code> 都推到同一個 <code>Sender&lt;ChannelMessage&gt;</code></li>
<li><strong>監控重啟（supervised restart）</strong>：每個 <code>listen</code> 都包在一個重試迴圈裡，失敗後指數退避重試</li>
<li><strong>信號量限流的 worker pool</strong>：從 mpsc 讀訊息，用 <code>Semaphore</code> 限制同時在飛的請求數</li>
</ol>

  <div class="mermaid">
    graph LR
    TG[Telegram] -->|listen| Q[(mpsc queue)]
    DC[Discord] -->|listen| Q
    SL[Slack] -->|listen| Q
    MT[Matrix ...] -->|listen| Q

    Q --> W1[Worker]
    Q --> W2[Worker]
    Q --> W3[Worker]

    W1 --> LLM[LLM Provider]
    W2 --> LLM
    W3 --> LLM
  </div>


  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 監控重啟
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">loop</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> result <span style="color:#f92672">=</span> ch.listen(tx.clone()).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 正常退出 → 重置退避；錯誤 → 等待後重試
</span></span></span><span style="display:flex;"><span>    tokio::time::sleep(Duration::from_secs(backoff)).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>    backoff <span style="color:#f92672">=</span> backoff.saturating_mul(<span style="color:#ae81ff">2</span>).min(max_backoff);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 信號量限流
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">let</span> semaphore <span style="color:#f92672">=</span> Arc::new(Semaphore::new(max_in_flight));
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">while</span> <span style="color:#66d9ef">let</span> Some(msg) <span style="color:#f92672">=</span> rx.recv().<span style="color:#66d9ef">await</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">let</span> permit <span style="color:#f92672">=</span> semaphore.acquire_owned().<span style="color:#66d9ef">await</span><span style="color:#f92672">?</span>;
</span></span><span style="display:flex;"><span>    workers.spawn(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">let</span> _permit <span style="color:#f92672">=</span> permit;  <span style="color:#75715e">// drop 時自動釋放
</span></span></span><span style="display:flex;"><span>        process_channel_message(worker_ctx, msg).<span style="color:#66d9ef">await</span>;
</span></span><span style="display:flex;"><span>    });
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>最大並發數是 <code>channel 數量 × 4</code>，夾在 8 到 64 之間。</p>
<h3 id="每則訊息的處理流程">每則訊息的處理流程</h3>
<p><code>process_channel_message()</code> 做的事遠不只是「丟給 LLM」：</p>
<ol>
<li>攔截 runtime 指令（<code>/models</code>、<code>/model</code>）— 支援不重啟切換 LLM provider</li>
<li>從 per-sender 對話歷史取得上下文（最多 50 輪）</li>
<li>從記憶體召回相關內容（向量相似度搜尋）</li>
<li>依平台注入特殊指令（例如告訴 Telegram 版的 LLM 可以用 <code>[IMAGE:path]</code> 語法發圖）</li>
<li>如果支援 draft update，先發 <code>&quot;...&quot;</code> 佔位，再串流更新</li>
<li>送進 LLM + tool call 迴圈（最多 300 秒 timeout）</li>
<li>把結果存回對話歷史，回覆給使用者</li>
</ol>
<hr>
<h2 id="gateway-vs-channel">Gateway vs Channel</h2>
<p>zeroclaw 有兩種接收訊息的模式，不要搞混：</p>
<ul>
<li><strong>Channel</strong>（<code>start_channels</code>）：agent 主動出去建立連線（WebSocket、long-polling），agent 是 client。</li>
<li><strong>Gateway</strong>（<code>src/gateway/</code>）：用 axum 開一個 HTTP server，等平台打 webhook 進來，agent 是 server。</li>
</ul>

  <div class="mermaid">
    graph TB
    subgraph channel_mode["Channel 模式（Agent 主動連出）"]
        direction LR
        A1[Agent] <-->|WebSocket / long-polling| P1["Telegram / Discord\nSlack / Matrix ..."]
    end

    subgraph gateway_mode["Gateway 模式（等 Webhook 打入）"]
        direction LR
        P2["WhatsApp\n(Meta Cloud API)"] -->|HTTP POST + HMAC 驗簽| A2["Agent\n(axum HTTP server)"]
    end
  </div>

<p>WhatsApp（Meta Cloud API）就是用 Gateway 模式，因為 Meta 只支援 webhook，不提供讓你長連的協議。Gateway 還內建了滑動視窗的 rate limiter、HMAC-SHA256 簽名驗證和請求去重（idempotency store）。</p>
<hr>
<h2 id="小結">小結</h2>
<p>zeroclaw Channel 設計的幾個值得學習的地方：</p>
<ul>
<li><strong>Push to mpsc，不用 callback</strong>：<code>listen</code> 只管推訊息，runtime 只管消費，兩邊完全解耦。</li>
<li><strong>Supervised restart 是一等公民</strong>：每個 channel 的生命週期都有人顧，不怕某個平台偶爾斷線。</li>
<li><strong>Draft updates 是 opt-in 擴充</strong>：預設 no-op，只有真的需要的平台實作，不污染介面。</li>
<li><strong>Gateway 和 Channel 分開</strong>：推（長連）和拉（webhook）兩種模式有各自的架構，互不混淆。</li>
</ul>
</div>

        <hr/>
      
                <span class="post-title">
          <a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-llm-provider/" title="zeroclaw 如何設計 LLM Provider 的抽象層">
            <h2>zeroclaw 如何設計 LLM Provider 的抽象層</h2>
          </a>
        </span>
        <div class="post-meta">
          <span class="post-date">February 19, 2026</span>
          <a href="/tils/"><span class="label label-info">TIL</span></a>
          
          <a href="/tags/rust"><span class="label label-primary">rust</span></a>
          
          <a href="/tags/agent"><span class="label label-primary">agent</span></a>
          
          <a href="/tags/design-patterns"><span class="label label-primary">design-patterns</span></a>
          
        </div>
        <div class="post-content"><blockquote>
<p>zeroclaw 是一個 Rust-first 的自主 Agent 執行時（autonomous agent runtime），設計目標是高效能、高穩定性、高擴充性與高安全性。它的架構以 trait 為核心，包含 Provider（LLM）、Channel（Telegram/Discord/Slack）、Tool、Memory、Security、Peripheral（STM32/RPi GPIO）等模組。這篇聚焦在它如何設計 LLM Provider 的抽象層，統一了 OpenAI、Anthropic、Gemini 等各種不同 API 的介面。</p>
</blockquote>
<h2 id="一個-trait一個必填方法">一個 Trait，一個必填方法</h2>
<p>整個抽象的核心是 <code>Provider</code> trait，但它聰明的地方在於：<strong>只有一個方法是必須實作的</strong>：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">trait</span> Provider: Send <span style="color:#f92672">+</span> Sync {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">chat_with_system</span>(
</span></span><span style="display:flex;"><span>        <span style="color:#f92672">&amp;</span>self,
</span></span><span style="display:flex;"><span>        system_prompt: Option<span style="color:#f92672">&lt;&amp;</span><span style="color:#66d9ef">str</span><span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>        message: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>        model: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>,
</span></span><span style="display:flex;"><span>        temperature: <span style="color:#66d9ef">f64</span>,
</span></span><span style="display:flex;"><span>    ) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 其他方法都有預設實作，最終都會呼叫 chat_with_system
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">simple_chat</span>(<span style="color:#f92672">&amp;</span>self, message: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, model: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>, temperature: <span style="color:#66d9ef">f64</span>) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">chat_with_history</span>(<span style="color:#f92672">&amp;</span>self, messages: <span style="color:#66d9ef">&amp;</span>[ChatMessage], <span style="color:#f92672">..</span>.) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">chat</span>(<span style="color:#f92672">&amp;</span>self, request: <span style="color:#a6e22e">ChatRequest</span><span style="color:#f92672">&lt;</span>&#39;_<span style="color:#f92672">&gt;</span>, <span style="color:#f92672">..</span>.) -&gt; <span style="color:#a6e22e">anyhow</span>::Result<span style="color:#f92672">&lt;</span>ChatResponse<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// ...
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>這意味著加一個新 provider 最少只需要 ~30 行程式碼。其他的 <code>simple_chat</code>、<code>chat_with_history</code> 這些便利方法，都有預設實作會幫你委派過去。</p>
<p>這裡用了 <a href="./2026-02-19-rust-async-trait.md"><code>async_trait</code></a> crate，因為 trait 裡的 async fn 需要特別處理才能支援 <code>dyn Provider</code>。</p>
<hr>
<h2 id="統一的訊息型別">統一的訊息型別</h2>
<p>各家 LLM API 的訊息格式其實大同小異，zeroclaw 定義了一套統一的型別：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ChatMessage</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> role: String,   <span style="color:#75715e">// &#34;system&#34;, &#34;user&#34;, &#34;assistant&#34;, &#34;tool&#34;
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> content: String,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ChatResponse</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> text: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> tool_calls: Vec<span style="color:#f92672">&lt;</span>ToolCall<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ToolCall</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> id: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> name: String,
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">pub</span> arguments: String,  <span style="color:#75715e">// JSON 字串
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p><code>ChatMessage</code> 還提供了工廠方法：<code>ChatMessage::user(&quot;hello&quot;)</code>、<code>ChatMessage::assistant(&quot;hi&quot;)</code> 這樣，寫起來很順。</p>
<p>多輪對話（包含 tool call 結果）則用一個 enum 來表達：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ConversationMessage</span> {
</span></span><span style="display:flex;"><span>    Chat(ChatMessage),
</span></span><span style="display:flex;"><span>    AssistantToolCalls { text: Option<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>, tool_calls: Vec<span style="color:#f92672">&lt;</span>ToolCall<span style="color:#f92672">&gt;</span> },
</span></span><span style="display:flex;"><span>    ToolResults(Vec<span style="color:#f92672">&lt;</span>ToolResultMessage<span style="color:#f92672">&gt;</span>),
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<hr>
<h2 id="decorator-pattern功能疊加">Decorator Pattern：功能疊加</h2>
<p><code>Provider</code> trait 自己也可以被包起來再實作 <code>Provider</code>，這讓功能可以自由組合。</p>
<h3 id="reliableprovider自動重試--api-key-輪換">ReliableProvider：自動重試 + API key 輪換</h3>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">struct</span> <span style="color:#a6e22e">ReliableProvider</span> {
</span></span><span style="display:flex;"><span>    providers: Vec<span style="color:#f92672">&lt;</span>(String, Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Provider<span style="color:#f92672">&gt;</span>)<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    max_retries: <span style="color:#66d9ef">u32</span>,
</span></span><span style="display:flex;"><span>    base_backoff_ms: <span style="color:#66d9ef">u64</span>,
</span></span><span style="display:flex;"><span>    api_keys: Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;</span>,
</span></span><span style="display:flex;"><span>    key_index: <span style="color:#a6e22e">AtomicUsize</span>,           <span style="color:#75715e">// 用 AtomicUsize 做 round-robin
</span></span></span><span style="display:flex;"><span>    model_fallbacks: <span style="color:#a6e22e">HashMap</span><span style="color:#f92672">&lt;</span>String, Vec<span style="color:#f92672">&lt;</span>String<span style="color:#f92672">&gt;&gt;</span>,
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>遇到 429 Rate Limit 就輪換 API key、指數退避重試；遇到 4xx 非 429 的錯誤就直接放棄；甚至還能解析 <code>Retry-After</code> header 來決定等多久。</p>
<h3 id="routerprovider按-model-名稱路由">RouterProvider：按 model 名稱路由</h3>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 用 &#34;hint:&#34; 前綴來指定路由
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">resolve</span>(<span style="color:#f92672">&amp;</span>self, model: <span style="color:#66d9ef">&amp;</span><span style="color:#66d9ef">str</span>) -&gt; (<span style="color:#66d9ef">usize</span>, String) {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some(hint) <span style="color:#f92672">=</span> model.strip_prefix(<span style="color:#e6db74">&#34;hint:&#34;</span>) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">if</span> <span style="color:#66d9ef">let</span> Some((idx, resolved_model)) <span style="color:#f92672">=</span> self.routes.get(hint) {
</span></span><span style="display:flex;"><span>            <span style="color:#66d9ef">return</span> (<span style="color:#f92672">*</span>idx, resolved_model.clone());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>    (self.default_index, model.to_string())
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>傳入 <code>&quot;hint:reasoning&quot;</code> 就會路由到你設定好對應「reasoning 任務」的 provider + model 組合。很適合多 provider 環境下的靈活調度。</p>
<hr>
<h2 id="tool-calling-的三種模式">Tool Calling 的三種模式</h2>
<p>各家 API 對 function calling 的格式差異很大，zeroclaw 用一個 enum 來表達：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">pub</span> <span style="color:#66d9ef">enum</span> <span style="color:#a6e22e">ToolsPayload</span> {
</span></span><span style="display:flex;"><span>    Gemini { function_declarations: Vec<span style="color:#f92672">&lt;</span>serde_json::Value<span style="color:#f92672">&gt;</span> },
</span></span><span style="display:flex;"><span>    Anthropic { tools: Vec<span style="color:#f92672">&lt;</span>serde_json::Value<span style="color:#f92672">&gt;</span> },
</span></span><span style="display:flex;"><span>    OpenAI { tools: Vec<span style="color:#f92672">&lt;</span>serde_json::Value<span style="color:#f92672">&gt;</span> },
</span></span><span style="display:flex;"><span>    PromptGuided { instructions: String },  <span style="color:#75715e">// 給不支援原生 tool call 的 provider 用
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>實際上支援三種策略：</p>
<ol>
<li><strong>原生 Tool Calling</strong>：Anthropic、OpenAI、Gemini 都有各自的格式，provider 各自轉換。</li>
<li><strong>Prompt 注入（PromptGuided）</strong>：把 tool 的說明文字注入到 system prompt，讓 LLM 用 <code>&lt;tool_call&gt;JSON&lt;/tool_call&gt;</code> 這樣的 XML tag 來回應。</li>
<li><strong>自動降級</strong>：<code>OpenAiCompatibleProvider</code> 會先嘗試原生格式，如果收到 <code>&quot;unknown parameter: tools&quot;</code> 這類錯誤，就自動切換到 prompt 注入模式。這樣就算某個 OpenAI 相容的 endpoint 不支援 tool call，也能無縫 fallback。</li>
</ol>
<hr>
<h2 id="各家-provider-的奇特之處">各家 Provider 的奇特之處</h2>
<p>實作各家 provider 的過程中，可以看到各家 API 設計的一些有趣差異：</p>
<p><strong>Anthropic</strong>：支援 Prompt Caching，會自動對大型 system prompt（&gt;3072 bytes）或長對話（&gt;4 則）加上 <code>cache_control: ephemeral</code>，降低費用。</p>
<p><strong>Gemini</strong>：是唯一把 API key 放在 query string（<code>?key=xxx</code>）而不是 header 裡的。而且 OAuth 使用者（Gemini CLI）必須打完全不同的 endpoint（<code>cloudcode-pa.googleapis.com</code>）。</p>
<p><strong>OpenAiCompatibleProvider</strong>：一個實作打遍幾乎所有 OpenAI 相容的 API——Venice、Cloudflare、Groq、Mistral、xAI、DeepSeek、Perplexity……超過 15 個 provider 都是它的變體。靠著 <code>AuthStyle</code> enum（Bearer、XApiKey、Custom）和可設定的 base URL 來區分。</p>
<hr>
<h2 id="工廠函式">工廠函式</h2>
<p>最後，使用者不需要直接 new 這些 struct，而是透過三個工廠函式：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 簡單建立單一 provider
</span></span></span><span style="display:flex;"><span>create_provider(name, api_key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 加上重試 + fallback 功能
</span></span></span><span style="display:flex;"><span>create_resilient_provider(<span style="color:#f92672">..</span>., reliability)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 加上多 provider 路由
</span></span></span><span style="display:flex;"><span>create_routed_provider(<span style="color:#f92672">..</span>., model_routes)</span></span></code></pre></div>

<p>API key 解析的優先順序是：明確傳入的參數 → provider 專屬的環境變數（如 <code>ANTHROPIC_API_KEY</code>）→ 通用的 <code>ZEROCLAW_API_KEY</code> → <code>API_KEY</code>。</p>
<hr>
<h2 id="小結">小結</h2>
<p>zeroclaw 的設計讓我印象深刻的幾個點：</p>
<ul>
<li><strong>最小介面原則</strong>：只強制一個方法，其他都是預設實作，加新 provider 成本很低。</li>
<li><strong>Decorator 而非繼承</strong>：retry、routing 都是包裝器，跟具體 provider 完全解耦。</li>
<li><strong>漸進式降級</strong>：tool calling 從原生到 prompt 注入的自動 fallback，使用者完全感知不到。</li>
<li><strong>務實</strong>：面對各家 API 的奇葩設計（Gemini 的 query param auth、各種 reasoning_content 欄位）直接在具體實作裡處理，不讓這些噪音污染核心抽象。</li>
</ul>
</div>

        <hr/>
      
                <span class="post-title">
          <a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-async-trait/" title="Rust 的 async_trait：為什麼 async fn 不能直接用在 trait 裡？">
            <h2>Rust 的 async_trait：為什麼 async fn 不能直接用在 trait 裡？</h2>
          </a>
        </span>
        <div class="post-meta">
          <span class="post-date">February 19, 2026</span>
          <a href="/tils/"><span class="label label-info">TIL</span></a>
          
          <a href="/tags/rust"><span class="label label-primary">rust</span></a>
          
          <a href="/tags/async"><span class="label label-primary">async</span></a>
          
          <a href="/tags/futures"><span class="label label-primary">futures</span></a>
          
          <a href="/tags/traits"><span class="label label-primary">traits</span></a>
          
        </div>
        <div class="post-content"><p>本文涵蓋為什麼 Rust trait 不支援 <code>async fn</code>、<code>async_trait</code> crate 如何解決這個問題、它的代價是什麼，以及 Rust 1.75 之後的原生支援現況。</p>
<h2 id="問題async-fn-不能直接用在-trait-裡">問題：async fn 不能直接用在 trait 裡</h2>
<p>如果你第一次在 Rust 寫 async 相關的 trait，很可能會直覺地這樣寫：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> MyTrait {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String; <span style="color:#75715e">// ❌ 編譯錯誤
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>但這在穩定版 Rust（1.75 之前）是不允許的。為什麼？</p>
<hr>
<h2 id="根本原因impl-trait-與-dyn-trait-的衝突">根本原因：impl Trait 與 dyn Trait 的衝突</h2>
<p><code>async fn</code> 是語法糖，它會被編譯器展開成回傳 <code>impl Future</code> 的普通函式：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">// 你寫的：
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">// 編譯器看到的：
</span></span></span><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">impl</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span> { <span style="color:#f92672">..</span>. }</span></span></code></pre></div>

<p>問題出在 trait 裡。每個實作 trait 的型別，其 <code>do_something</code> 都會回傳一個<strong>不同的具體 Future 型別</strong>：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyTrait <span style="color:#66d9ef">for</span> StructA {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 回傳型別是某個只有編譯器知道名字的 Future_A
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyTrait <span style="color:#66d9ef">for</span> StructB {
</span></span><span style="display:flex;"><span>    <span style="color:#75715e">// 回傳型別是另一個 Future_B，跟 Future_A 完全不同
</span></span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String { <span style="color:#f92672">..</span>. }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>這讓 trait 無法做到 <strong>object-safe</strong>（也就是無法用 <code>dyn MyTrait</code>），因為動態派發需要在執行期才知道要呼叫哪個實作，但每個實作的回傳型別大小不同，vtable 根本無法表達。</p>
<hr>
<h2 id="解法async_trait-crate">解法：async_trait crate</h2>
<p><code>async_trait</code> 是由 David Tolnay（<code>serde</code>、<code>anyhow</code> 的作者）開發的 procedural macro，它的做法是把所有 <code>async fn</code> 的回傳值<strong>統一包進 <code>Box</code></strong>：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">use</span> async_trait::async_trait;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> MyTrait {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e">#[async_trait]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyTrait <span style="color:#66d9ef">for</span> MyStruct {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String {
</span></span><span style="display:flex;"><span>        <span style="color:#e6db74">&#34;hello&#34;</span>.to_string()
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>macro 展開後，實際上變成這樣：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> MyTrait {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;&gt;</span>;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">impl</span> MyTrait <span style="color:#66d9ef">for</span> MyStruct {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; <span style="color:#a6e22e">Pin</span><span style="color:#f92672">&lt;</span>Box<span style="color:#f92672">&lt;</span><span style="color:#66d9ef">dyn</span> Future<span style="color:#f92672">&lt;</span>Output <span style="color:#f92672">=</span> String<span style="color:#f92672">&gt;</span> <span style="color:#f92672">+</span> Send <span style="color:#f92672">+</span> &#39;_<span style="color:#f92672">&gt;&gt;</span> {
</span></span><span style="display:flex;"><span>        Box::pin(<span style="color:#66d9ef">async</span> <span style="color:#66d9ef">move</span> {
</span></span><span style="display:flex;"><span>            <span style="color:#e6db74">&#34;hello&#34;</span>.to_string()
</span></span><span style="display:flex;"><span>        })
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>回傳型別統一成 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>，大小固定，vtable 可以表達，<code>dyn MyTrait</code> 就可以正常運作了。</p>
<hr>
<h2 id="代價與限制">代價與限制</h2>
<h3 id="堆積分配heap-allocation">堆積分配（Heap allocation）</h3>
<p>每次呼叫 async trait method，都會觸發一次 <code>Box::pin()</code>，也就是一次 heap 分配。對於高頻呼叫的場景，這個開銷是需要考慮的。</p>
<h3 id="send-bound">Send bound</h3>
<p>預設情況下，<code>async_trait</code> 要求產生的 Future 必須是 <code>Send</code>（可以跨執行緒傳遞），適合多執行緒 async runtime（如 Tokio）。</p>
<p>如果你的情境不需要 <code>Send</code>（例如單執行緒 runtime），可以這樣關掉：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#75715e">#[async_trait(?Send)]</span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> MyTrait {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String;
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<h3 id="生命週期複雜度">生命週期複雜度</h3>
<p>macro 會自動處理大部分生命週期，但在一些邊緣情況（例如 <code>&amp;self</code> 裡有複雜的借用關係）還是可能需要手動標注，錯誤訊息也可能比較難讀。</p>
<hr>
<h2 id="rust-175-的原生支援">Rust 1.75 的原生支援</h2>
<p>Rust 1.75（2023 年 12 月）穩定了 <strong>Return Position Impl Trait in Trait（RPITIT）</strong>，讓 <code>async fn</code> 可以直接用在 trait 裡：</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">trait</span> MyTrait {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">async</span> <span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">do_something</span>(<span style="color:#f92672">&amp;</span>self) -&gt; String; <span style="color:#75715e">// ✅ Rust 1.75+ 可以！
</span></span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>不需要任何外部 crate，不需要 <code>Box</code>，沒有 heap 分配。</p>
<h3 id="但-dyn-trait-仍有限制">但 dyn Trait 仍有限制</h3>
<p>原生支援的版本有一個重要限制：<strong>動態派發（<code>dyn MyTrait</code>）尚未完全支援</strong>。</p>

  <div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;"><code class="language-rust" data-lang="rust"><span style="display:flex;"><span><span style="color:#66d9ef">fn</span> <span style="color:#a6e22e">call</span>(obj: <span style="color:#66d9ef">&amp;</span><span style="color:#a6e22e">dyn</span> MyTrait) {  <span style="color:#75715e">// ⚠️ 可能有限制
</span></span></span><span style="display:flex;"><span>    obj.do_something();
</span></span><span style="display:flex;"><span>}</span></span></code></pre></div>

<p>如果你需要 <code>dyn Trait</code>，目前仍建議使用 <code>async_trait</code> crate，或者搭配 <code>dynosaur</code> 等新興 crate 來橋接。</p>
<hr>
<h2 id="async_trait-與-pin-的關係">async_trait 與 Pin 的關係</h2>
<p><code>async_trait</code> 展開後的回傳型別是 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code>，這裡的 <code>Pin</code> 是必要的——因為 <code>dyn Future</code> 可能是自引用的（async block 裡可能跨 await 持有引用），必須保證它被 poll 的過程中不會被移動。</p>
<p>這也是為什麼 <code>async_trait</code> 的文件裡，你會看到它與 <code>Pin</code>、<code>Box</code> 密不可分。如果你對 <code>Pin</code> 還不熟悉，可以先閱讀<a href="./rust-pin-blog.md">《深入理解 Rust 的 Pin》</a>。</p>
<hr>
<h2 id="應該用哪個">應該用哪個？</h2>
<table>
  <thead>
      <tr>
          <th>情境</th>
          <th>建議</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Rust 1.75+，不需要 <code>dyn Trait</code></td>
          <td>原生 <code>async fn in trait</code></td>
      </tr>
      <tr>
          <td>需要 <code>dyn Trait</code></td>
          <td><code>async_trait</code> crate</td>
      </tr>
      <tr>
          <td>效能極度敏感，避免 heap 分配</td>
          <td>考慮手動實作或 <code>impl Trait</code> 參數</td>
      </tr>
      <tr>
          <td>舊版 Rust（&lt; 1.75）</td>
          <td><code>async_trait</code> crate</td>
      </tr>
  </tbody>
</table>
<hr>
<h2 id="總結">總結</h2>
<ul>
<li>Rust trait 原本不支援 <code>async fn</code>，根本原因是每個實作的 Future 型別不同，無法做到 object-safe。</li>
<li><code>async_trait</code> crate 透過把回傳值包進 <code>Pin&lt;Box&lt;dyn Future&gt;&gt;</code> 解決這個問題，代價是每次呼叫需要 heap 分配。</li>
<li>Rust 1.75 穩定了原生的 <code>async fn in trait</code>，但動態派發（<code>dyn Trait</code>）的支援仍不完整，<code>async_trait</code> 在這個場景仍有其價值。</li>
</ul>
</div>

        <hr/>
      
    </div>
    <div class="col-md-3 sidebar">
      <aside>
  <section>
    <img class="img-thumbnail" src="/images/patrick.jpg">
    <div class="author-about">Patrick Tsai is a software developer in heart. He is interested in mobile, web, and
      multimedia programming.</div>
  </section>
  <section>
  <ul class="list-group">
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-memory/">zeroclaw 如何設計 Memory 的抽象層</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-tools/">zeroclaw 如何設計 Tool 的抽象層</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-channel/">zeroclaw 如何設計 Channel 的抽象層</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-zeroclaw-llm-provider/">zeroclaw 如何設計 LLM Provider 的抽象層</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-async-trait/">Rust 的 async_trait：為什麼 async fn 不能直接用在 trait 裡？</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-pin/">理解 Rust 的 Pin：從問題到解法</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/posts/2026/02-18-media-metadata-explorer/">Rust 媒體元資料探索器：用 FFmpeg 剖析影音檔案與打造 TUI</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/posts/2026/02-15-tilesplit-wasm/">TileSplit WASM：把 Ultra HDR 圖片切割搬到瀏覽器</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/posts/2026/02-14-tilesplit/">TileSplit：用 Rust 打造保留 Ultra HDR 資訊的圖片切割工具</a></li>
  
    <li class="list-group-item"><a href="https://blog.simplypatrick.com/posts/2026/02-13-rust-proc-macro-builder-derive/">Rust Proc Macro：builder-derive 實戰</a></li>
  
  </ul>
</section>

</aside>
    </div>
  </div>
    </div>

    <div class="row">
    <div class="col-md-12">
      <footer id="footer" class="text-center">
        © Patrick Tsai 2003-2026.
        Proudly powered by <a href="http://gohugo.io/">Hugo</a>.
      </footer>
    </div>
  </div>

  <script src="//ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
  <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
  <script src="/js/bootstrap-toc.min.js"></script>
  <script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-73968064-1', 'auto');
  ga('send', 'pageview');

</script>


  <script src="/js/prism.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js"></script>
  <script>
    mermaid.initialize({ startOnLoad: true });
  </script>

</body>
</html>
