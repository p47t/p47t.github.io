<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simply Patrick </title>
    <link>https://blog.simplypatrick.com/tags/async/</link>
    <author>Patrick Tsai</author>
    <rights>Copyright (c) 2003 - 2016, Patrick Tsai; all rights reserved.</rights>
    <updated>2026-02-19 02:39:27 -0800 -0800</updated>
    
    <item>
      <title>Rust 的 async_trait：為什麼 async fn 不能直接用在 trait 裡？</title>
      <link>https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-async-trait/</link>
      <pubDate>Thu, 19 Feb 2026 02:39:27 -0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-async-trait/</guid>
      <description>&lt;p&gt;本文涵蓋為什麼 Rust trait 不支援 &lt;code&gt;async fn&lt;/code&gt;、&lt;code&gt;async_trait&lt;/code&gt; crate 如何解決這個問題、它的代價是什麼，以及 Rust 1.75 之後的原生支援現況。&lt;/p&gt;
&lt;h2 id=&#34;問題async-fn-不能直接用在-trait-裡&#34;&gt;問題：async fn 不能直接用在 trait 裡&lt;/h2&gt;
&lt;p&gt;如果你第一次在 Rust 寫 async 相關的 trait，很可能會直覺地這樣寫：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; MyTrait {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String; &lt;span style=&#34;color:#75715e&#34;&gt;// ❌ 編譯錯誤
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;但這在穩定版 Rust（1.75 之前）是不允許的。為什麼？&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;根本原因impl-trait-與-dyn-trait-的衝突&#34;&gt;根本原因：impl Trait 與 dyn Trait 的衝突&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async fn&lt;/code&gt; 是語法糖，它會被編譯器展開成回傳 &lt;code&gt;impl Future&lt;/code&gt; 的普通函式：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 你寫的：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String { &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;. }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 編譯器看到的：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;impl&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; { &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;. }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;問題出在 trait 裡。每個實作 trait 的型別，其 &lt;code&gt;do_something&lt;/code&gt; 都會回傳一個&lt;strong&gt;不同的具體 Future 型別&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; MyTrait &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; StructA {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別是某個只有編譯器知道名字的 Future_A
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String { &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;. }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; MyTrait &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; StructB {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 回傳型別是另一個 Future_B，跟 Future_A 完全不同
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String { &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;. }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這讓 trait 無法做到 &lt;strong&gt;object-safe&lt;/strong&gt;（也就是無法用 &lt;code&gt;dyn MyTrait&lt;/code&gt;），因為動態派發需要在執行期才知道要呼叫哪個實作，但每個實作的回傳型別大小不同，vtable 根本無法表達。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;解法async_trait-crate&#34;&gt;解法：async_trait crate&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async_trait&lt;/code&gt; 是由 David Tolnay（&lt;code&gt;serde&lt;/code&gt;、&lt;code&gt;anyhow&lt;/code&gt; 的作者）開發的 procedural macro，它的做法是把所有 &lt;code&gt;async fn&lt;/code&gt; 的回傳值&lt;strong&gt;統一包進 &lt;code&gt;Box&lt;/code&gt;&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; async_trait::async_trait;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[async_trait]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; MyTrait {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[async_trait]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; MyTrait &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; MyStruct {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;.to_string()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;macro 展開後，實際上變成這樣：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; MyTrait {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; MyTrait &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; MyStruct {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;dyn&lt;/span&gt; Future&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; Send &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &amp;#39;_&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        Box::pin(&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;move&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;.to_string()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回傳型別統一成 &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future&amp;gt;&amp;gt;&lt;/code&gt;，大小固定，vtable 可以表達，&lt;code&gt;dyn MyTrait&lt;/code&gt; 就可以正常運作了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;代價與限制&#34;&gt;代價與限制&lt;/h2&gt;
&lt;h3 id=&#34;堆積分配heap-allocation&#34;&gt;堆積分配（Heap allocation）&lt;/h3&gt;
&lt;p&gt;每次呼叫 async trait method，都會觸發一次 &lt;code&gt;Box::pin()&lt;/code&gt;，也就是一次 heap 分配。對於高頻呼叫的場景，這個開銷是需要考慮的。&lt;/p&gt;
&lt;h3 id=&#34;send-bound&#34;&gt;Send bound&lt;/h3&gt;
&lt;p&gt;預設情況下，&lt;code&gt;async_trait&lt;/code&gt; 要求產生的 Future 必須是 &lt;code&gt;Send&lt;/code&gt;（可以跨執行緒傳遞），適合多執行緒 async runtime（如 Tokio）。&lt;/p&gt;
&lt;p&gt;如果你的情境不需要 &lt;code&gt;Send&lt;/code&gt;（例如單執行緒 runtime），可以這樣關掉：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[async_trait(?Send)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; MyTrait {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;生命週期複雜度&#34;&gt;生命週期複雜度&lt;/h3&gt;
&lt;p&gt;macro 會自動處理大部分生命週期，但在一些邊緣情況（例如 &lt;code&gt;&amp;amp;self&lt;/code&gt; 裡有複雜的借用關係）還是可能需要手動標注，錯誤訊息也可能比較難讀。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;rust-175-的原生支援&#34;&gt;Rust 1.75 的原生支援&lt;/h2&gt;
&lt;p&gt;Rust 1.75（2023 年 12 月）穩定了 &lt;strong&gt;Return Position Impl Trait in Trait（RPITIT）&lt;/strong&gt;，讓 &lt;code&gt;async fn&lt;/code&gt; 可以直接用在 trait 裡：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;trait&lt;/span&gt; MyTrait {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;do_something&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self) -&amp;gt; String; &lt;span style=&#34;color:#75715e&#34;&gt;// ✅ Rust 1.75+ 可以！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;不需要任何外部 crate，不需要 &lt;code&gt;Box&lt;/code&gt;，沒有 heap 分配。&lt;/p&gt;
&lt;h3 id=&#34;但-dyn-trait-仍有限制&#34;&gt;但 dyn Trait 仍有限制&lt;/h3&gt;
&lt;p&gt;原生支援的版本有一個重要限制：&lt;strong&gt;動態派發（&lt;code&gt;dyn MyTrait&lt;/code&gt;）尚未完全支援&lt;/strong&gt;。&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;call&lt;/span&gt;(obj: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;dyn&lt;/span&gt; MyTrait) {  &lt;span style=&#34;color:#75715e&#34;&gt;// ⚠️ 可能有限制
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    obj.do_something();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果你需要 &lt;code&gt;dyn Trait&lt;/code&gt;，目前仍建議使用 &lt;code&gt;async_trait&lt;/code&gt; crate，或者搭配 &lt;code&gt;dynosaur&lt;/code&gt; 等新興 crate 來橋接。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;async_trait-與-pin-的關係&#34;&gt;async_trait 與 Pin 的關係&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;async_trait&lt;/code&gt; 展開後的回傳型別是 &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future&amp;gt;&amp;gt;&lt;/code&gt;，這裡的 &lt;code&gt;Pin&lt;/code&gt; 是必要的——因為 &lt;code&gt;dyn Future&lt;/code&gt; 可能是自引用的（async block 裡可能跨 await 持有引用），必須保證它被 poll 的過程中不會被移動。&lt;/p&gt;
&lt;p&gt;這也是為什麼 &lt;code&gt;async_trait&lt;/code&gt; 的文件裡，你會看到它與 &lt;code&gt;Pin&lt;/code&gt;、&lt;code&gt;Box&lt;/code&gt; 密不可分。如果你對 &lt;code&gt;Pin&lt;/code&gt; 還不熟悉，可以先閱讀&lt;a href=&#34;./rust-pin-blog.md&#34;&gt;《深入理解 Rust 的 Pin》&lt;/a&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;應該用哪個&#34;&gt;應該用哪個？&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;情境&lt;/th&gt;
          &lt;th&gt;建議&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Rust 1.75+，不需要 &lt;code&gt;dyn Trait&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;原生 &lt;code&gt;async fn in trait&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;需要 &lt;code&gt;dyn Trait&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;async_trait&lt;/code&gt; crate&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;效能極度敏感，避免 heap 分配&lt;/td&gt;
          &lt;td&gt;考慮手動實作或 &lt;code&gt;impl Trait&lt;/code&gt; 參數&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;舊版 Rust（&amp;lt; 1.75）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;async_trait&lt;/code&gt; crate&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;總結&#34;&gt;總結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;Rust trait 原本不支援 &lt;code&gt;async fn&lt;/code&gt;，根本原因是每個實作的 Future 型別不同，無法做到 object-safe。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;async_trait&lt;/code&gt; crate 透過把回傳值包進 &lt;code&gt;Pin&amp;lt;Box&amp;lt;dyn Future&amp;gt;&amp;gt;&lt;/code&gt; 解決這個問題，代價是每次呼叫需要 heap 分配。&lt;/li&gt;
&lt;li&gt;Rust 1.75 穩定了原生的 &lt;code&gt;async fn in trait&lt;/code&gt;，但動態派發（&lt;code&gt;dyn Trait&lt;/code&gt;）的支援仍不完整，&lt;code&gt;async_trait&lt;/code&gt; 在這個場景仍有其價值。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>理解 Rust 的 Pin：從問題到解法</title>
      <link>https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-pin/</link>
      <pubDate>Thu, 19 Feb 2026 02:16:20 -0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/tils/2026/2026-02-19-rust-pin/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;涵蓋 &lt;code&gt;Pin&lt;/code&gt;、&lt;code&gt;Unpin&lt;/code&gt;、&lt;code&gt;pin!&lt;/code&gt; macro、&lt;code&gt;tokio::pin!&lt;/code&gt;，以及它們背後的設計邏輯。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;問題的根源自引用結構&#34;&gt;問題的根源：自引用結構&lt;/h2&gt;
&lt;p&gt;要理解 &lt;code&gt;Pin&lt;/code&gt;，得先知道它解決的是什麼問題。&lt;/p&gt;
&lt;p&gt;在 Rust 中，「移動（move）」一個值，本質上是把它的記憶體內容複製到新位置，然後讓舊的失效。大多數情況下這完全沒問題，但有一種情況會爆炸——&lt;strong&gt;自引用結構（self-referential struct）&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;SelfRef&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    data: String,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    ptr: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; String,  &lt;span style=&#34;color:#75715e&#34;&gt;// 指向自己的 data！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果這個結構被移動了，&lt;code&gt;data&lt;/code&gt; 跑到新地址，但 &lt;code&gt;ptr&lt;/code&gt; 還指著舊地址，就成了&lt;strong&gt;懸空指標（dangling pointer）&lt;/strong&gt;，記憶體安全直接玩完。&lt;/p&gt;
&lt;p&gt;這聽起來像是很少見的邊緣案例，但其實非常普遍——&lt;strong&gt;&lt;code&gt;async/await&lt;/code&gt; 產生的 &lt;code&gt;Future&lt;/code&gt; 幾乎都是自引用結構&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;example&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;vec!&lt;/span&gt;[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;3&lt;/span&gt;];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    some_await().&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{:?}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, data); &lt;span style=&#34;color:#75715e&#34;&gt;// Future 需要跨 await 持有對 data 的引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;編譯器為這個 &lt;code&gt;async fn&lt;/code&gt; 生成的狀態機，會同時持有 &lt;code&gt;data&lt;/code&gt; 和指向它的引用，這就是自引用。&lt;/p&gt;
&lt;h3 id=&#34;狀態機長什麼樣子&#34;&gt;狀態機長什麼樣子？&lt;/h3&gt;
&lt;p&gt;編譯器大致會生成這樣的狀態機（簡化的偽代碼）：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 每個 await 點對應一個狀態
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;enum&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ExampleFuture&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 狀態 0：尚未開始執行（第一次 poll 之前）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 此時沒有任何自引用，只是普通的初始值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Start,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 狀態 1：在 some_await().await 暫停，等待 inner future 完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ⚠️ 自引用在這裡出現！
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    AwaitingInner {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        data: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,               &lt;span style=&#34;color:#75715e&#34;&gt;// 擁有 data
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        reference: &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 指向上面那個 data！← 自引用
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        inner_fut: &lt;span style=&#34;color:#a6e22e&#34;&gt;SomeAwaitFuture&lt;/span&gt;,   &lt;span style=&#34;color:#75715e&#34;&gt;// 正在等待的 inner future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 狀態 2：完成
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Done,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;問題在於：如果 &lt;code&gt;AwaitingInner&lt;/code&gt; 這個 variant 被 &lt;strong&gt;move&lt;/strong&gt; 到新的記憶體位置，&lt;code&gt;data&lt;/code&gt; 跑到新地址，但 &lt;code&gt;reference&lt;/code&gt; 還指著舊地址——&lt;strong&gt;懸空指標，記憶體安全崩潰&lt;/strong&gt;。&lt;/p&gt;

  &lt;div class=&#34;mermaid&#34;&gt;
    graph LR
    subgraph before[&#34;移動前（位址 0x100）&#34;]
        d1[&#34;data: [1,2,3]&#34;]
        r1[&#34;ref: 0x100&#34;]
        r1 -- &#34;✅ 正確指向&#34; --&gt; d1
    end

    subgraph after[&#34;移動後（位址 0x200）&#34;]
        d2[&#34;data: [1,2,3]&#34;]
        r2[&#34;ref: 0x100&#34;]
    end

    before -- &#34;move&#34; --&gt; after
    r2 -. &#34;⚠️ 懸空指標！&#34; .-&gt; d1
  &lt;/div&gt;

&lt;p&gt;這就是為什麼 &lt;code&gt;async&lt;/code&gt; Future 一旦開始被 poll（進入 &lt;code&gt;AwaitingInner&lt;/code&gt; 狀態），就&lt;strong&gt;絕對不能再被移動&lt;/strong&gt;。&lt;code&gt;Pin&lt;/code&gt; 的存在，就是用型別系統來強制保證這件事。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;pin-的核心思想&#34;&gt;Pin 的核心思想&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Pin&amp;lt;P&amp;gt;&lt;/code&gt; 是一個包裝器，它對指標 &lt;code&gt;P&lt;/code&gt;（如 &lt;code&gt;&amp;amp;mut T&lt;/code&gt; 或 &lt;code&gt;Box&amp;lt;T&amp;gt;&lt;/code&gt;）做出保證：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「被指向的值 &lt;code&gt;T&lt;/code&gt;，在它被 drop 之前，不會再被移動。」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::pin::Pin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 普通的 Box，裡面的值可以被 move 出來
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; b: Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Box::new(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;.into());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; s: String &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;b; &lt;span style=&#34;color:#75715e&#34;&gt;// ✅ 可以 move
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// Pin 住的 Box，裡面的值無法被安全地 move 出來
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; p: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Box&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Box::pin(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;hello&amp;#34;&lt;/span&gt;.into());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// let s: String = *p; // ❌ 無法取得 &amp;amp;mut T 來 move
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Pin&lt;/code&gt; 本身不是什麼魔法鎖，而是透過&lt;strong&gt;型別系統&lt;/strong&gt;來防止你取得能夠 move 該值的 &lt;code&gt;&amp;amp;mut T&lt;/code&gt;。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;unpin大多數型別其實不在乎&#34;&gt;Unpin：大多數型別其實不在乎&lt;/h2&gt;
&lt;p&gt;Rust 有個 auto trait 叫 &lt;code&gt;Unpin&lt;/code&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;實作了 &lt;code&gt;Unpin&lt;/code&gt; 的型別，即使被 Pin 住也可以安全地移動，因為它們不是自引用結構。&lt;/li&gt;
&lt;li&gt;幾乎所有普通型別（&lt;code&gt;i32&lt;/code&gt;、&lt;code&gt;String&lt;/code&gt;、&lt;code&gt;Vec&lt;/code&gt;、&amp;hellip;）都自動實作 &lt;code&gt;Unpin&lt;/code&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;async&lt;/code&gt; 產生的 Future 不實作 &lt;code&gt;Unpin&lt;/code&gt;&lt;/strong&gt;，因為它們可能是自引用的。&lt;/li&gt;
&lt;/ul&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;普通型別（String、Vec...）→ 自動 impl Unpin  → Pin 對它形同虛設
async fn 的 Future        → 不 impl Unpin   → Pin 真正發揮作用&lt;/code&gt;&lt;/pre&gt;

&lt;hr&gt;
&lt;h2 id=&#34;pin-的兩個重要方法&#34;&gt;Pin 的兩個重要方法&lt;/h2&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 如果 T: Unpin，可以安全拿到 &amp;amp;mut T
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;P: &lt;span style=&#34;color:#a6e22e&#34;&gt;DerefMut&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Target: Unpin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; Pin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_mut&lt;/span&gt;(self) -&amp;gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; T
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 不管 T 是否 Unpin，都能繼續操作 Pin 住的值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;P: &lt;span style=&#34;color:#a6e22e&#34;&gt;DerefMut&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; Pin&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;P&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;as_mut&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; T&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;手動實作-future-時的-pin&#34;&gt;手動實作 Future 時的 Pin&lt;/h2&gt;
&lt;p&gt;Pin 最直接的使用場景之一是手動實作 &lt;code&gt;Future&lt;/code&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Future &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; MyFuture {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;type&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Output&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// self 必須是 Pin&amp;lt;&amp;amp;mut Self&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;poll&lt;/span&gt;(self: &lt;span style=&#34;color:#a6e22e&#34;&gt;Pin&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, cx: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Context) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Poll&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;i32&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;todo!&lt;/span&gt;()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;hr&gt;
&lt;h2 id=&#34;pin-macro把值-pin-在-stack-上&#34;&gt;pin! macro：把值 pin 在 Stack 上&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Box::pin()&lt;/code&gt; 把值放在 heap 上，有分配成本。很多情況下我們希望把 Future pin 在 &lt;strong&gt;stack&lt;/strong&gt; 上，這時就需要 &lt;code&gt;pin!&lt;/code&gt; macro。&lt;/p&gt;
&lt;p&gt;手動在 stack 上 pin 既麻煩又需要 &lt;code&gt;unsafe&lt;/code&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; future &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; some_async_fn();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 你必須保證之後不會 move future
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; pinned &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsafe&lt;/span&gt; { Pin::new_unchecked(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; future) };&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;pin!&lt;/code&gt; macro 讓這件事變得安全且方便。&lt;/p&gt;
&lt;h3 id=&#34;tokiopin&#34;&gt;&lt;code&gt;tokio::pin!&lt;/code&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tokio::pin!&lt;/code&gt; 接受變數名稱，直接在當前 scope 做 shadowing：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// tokio::pin! 大致展開成這樣：
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;macro_rules&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt; pin {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    (&lt;span style=&#34;color:#75715e&#34;&gt;$x&lt;/span&gt;:&lt;span style=&#34;color:#a6e22e&#34;&gt;ident&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;$x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;$x&lt;/span&gt;;                                       &lt;span style=&#34;color:#75715e&#34;&gt;// (1) move 到新綁定
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;$x&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;unsafe&lt;/span&gt; { Pin::new_unchecked(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; &lt;span style=&#34;color:#75715e&#34;&gt;$x&lt;/span&gt;) };  &lt;span style=&#34;color:#75715e&#34;&gt;// (2) shadow 成 Pin&amp;lt;&amp;amp;mut T&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;使用方式：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::pin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; future &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; some_async_fn();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pin!&lt;/span&gt;(future); &lt;span style=&#34;color:#75715e&#34;&gt;// future 的型別現在是 Pin&amp;lt;&amp;amp;mut impl Future&amp;gt;
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;future.&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;步驟 (1) 把值 move 到新綁定，步驟 (2) 把名字蓋掉，改成 &lt;code&gt;Pin&amp;lt;&amp;amp;mut T&amp;gt;&lt;/code&gt;。此後你只看得到 Pin 版本，原本可以 move 的那個綁定已不可見，借用規則自然防止你移動它。&lt;/p&gt;
&lt;h3 id=&#34;stdpinpinrust-168&#34;&gt;&lt;code&gt;std::pin::pin!&lt;/code&gt;（Rust 1.68+）&lt;/h3&gt;
&lt;p&gt;標準庫的版本接受任意表達式，靠的是另一個機制——&lt;strong&gt;Temporary Lifetime Extension（暫存值生命週期延伸）&lt;/strong&gt;：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::pin::pin;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; fut &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;pin!&lt;/span&gt;(some_async_fn());&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;展開後：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; fut &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; _pinned &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; some_async_fn();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;unsafe&lt;/span&gt; { Pin::new_unchecked(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; _pinned) }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Rust 編譯器發現回傳值裡含有對 block 內部暫存值的引用，於是自動把 &lt;code&gt;_pinned&lt;/code&gt; 的生命週期延伸到與 &lt;code&gt;fut&lt;/code&gt; 相同的 scope，確保不會出現懸空指標。這是編譯器特殊規則，不是 unsafe hack。&lt;/p&gt;
&lt;h3 id=&#34;兩者對比&#34;&gt;兩者對比&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;tokio::pin!&lt;/code&gt;&lt;/th&gt;
          &lt;th&gt;&lt;code&gt;std::pin::pin!&lt;/code&gt;&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;接受&lt;/td&gt;
          &lt;td&gt;變數名 &lt;code&gt;ident&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;任意表達式 &lt;code&gt;expr&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;機制&lt;/td&gt;
          &lt;td&gt;變數 shadowing&lt;/td&gt;
          &lt;td&gt;Temporary lifetime extension&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;語法&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;pin!(fut);&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;let fut = pin!(expr);&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;move-進-pin-不就跟-pin-的目的矛盾&#34;&gt;「move 進 &lt;code&gt;pin!&lt;/code&gt; 不就跟 Pin 的目的矛盾？」&lt;/h2&gt;
&lt;p&gt;這是個很常見的疑惑。答案是：&lt;strong&gt;move 發生在 pin 之前，Pin 的承諾是從 pin 的那一刻之後才開始的。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Pin 的合約不是「這個值永遠不能移動」，而是：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;「一旦被 pin 住之後，就不能再移動。」&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;code&gt;async fn&lt;/code&gt; 產生的 Future，在&lt;strong&gt;第一次被 poll 之前&lt;/strong&gt;，內部根本還沒有任何自引用，只是一個普通的初始狀態機。自引用是在 poll 的過程中才逐漸形成的：&lt;/p&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;[建立 Future] → move 進 _pinned → [Pin 住] → [第一次 poll] → 自引用開始形成
                    ✅ 安全                       ✅ 此後不再 move&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以 &lt;code&gt;pin!&lt;/code&gt; 在 pin 之前 move 值是完全合法的，並不矛盾。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;最重要的使用場景select&#34;&gt;最重要的使用場景：select!&lt;/h2&gt;
&lt;p&gt;這是你最常需要 &lt;code&gt;pin!&lt;/code&gt; 的地方。&lt;code&gt;tokio::select!&lt;/code&gt; 需要能夠&lt;strong&gt;跨多次 poll 同一個 Future&lt;/strong&gt;，每次都必須是同一個 pinned Future，不能 move 它：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; tokio::{pin, time};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; std::time::Duration;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[tokio::main]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;main&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; long_operation &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; do_something_slow();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;pin!&lt;/span&gt;(long_operation);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; interval &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; time::interval(Duration::from_secs(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;loop&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        tokio::&lt;span style=&#34;color:#a6e22e&#34;&gt;select!&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            result &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; long_operation &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;完成：&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{:?}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;, result);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;break&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            _ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; interval.tick() &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#a6e22e&#34;&gt;println!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;還在等待中...&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;如果沒有 &lt;code&gt;pin!&lt;/code&gt;，每次進入 loop 都會 move &lt;code&gt;long_operation&lt;/code&gt;，之前的 poll 狀態就丟失了。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;什麼時候用哪個&#34;&gt;什麼時候用哪個？&lt;/h2&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;情境&lt;/th&gt;
          &lt;th&gt;建議&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;現代專案，不依賴 Tokio&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;std::pin::pin!&lt;/code&gt;（Rust 1.68+）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Tokio 專案&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;tokio::pin!&lt;/code&gt; 或 &lt;code&gt;std::pin::pin!&lt;/code&gt; 皆可&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;需要跨執行緒傳遞&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;Box::pin()&lt;/code&gt;（heap 分配，Box 本身可 move）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;效能敏感，避免 heap 分配&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;pin!&lt;/code&gt;（stack）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;hr&gt;
&lt;h2 id=&#34;總結&#34;&gt;總結&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Pin&lt;/strong&gt; 是 Rust 用型別系統做出的「這個值不能再被移動」的承諾，專為自引用結構（尤其是 async Future）而設計。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Unpin&lt;/strong&gt; 讓普通型別不受 Pin 影響，只有真正需要固定位置的型別（如 async Future）才會受到約束。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;tokio::pin!&lt;/code&gt;&lt;/strong&gt; 靠 shadowing，&lt;strong&gt;&lt;code&gt;std::pin::pin!&lt;/code&gt;&lt;/strong&gt; 靠 temporary lifetime extension，兩者都能安全地把值 pin 在 stack 上。&lt;/li&gt;
&lt;li&gt;Pin 的承諾從「pin 的那一刻」開始，pin 之前的 move 完全合法。&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>
