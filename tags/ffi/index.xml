<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simply Patrick </title>
    <link>https://blog.simplypatrick.com/tags/ffi/</link>
    <author>Patrick Tsai</author>
    <rights>Copyright (c) 2003 - 2016, Patrick Tsai; all rights reserved.</rights>
    <updated>2026-02-18 00:00:00 -0800 -0800</updated>
    
    <item>
      <title>Rust 媒體元資料探索器：用 FFmpeg 剖析影音檔案與打造 TUI</title>
      <link>https://blog.simplypatrick.com/posts/2026/02-18-media-metadata-explorer/</link>
      <pubDate>Wed, 18 Feb 2026 00:00:00 -0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/posts/2026/02-18-media-metadata-explorer/</guid>
      <description>

  
    &lt;img src=&#34;https://blog.simplypatrick.com/posts/2026/02-18-media-metadata-explorer/featured.svg&#34; alt=&#34;featured.svg&#34; class=&#34;img-responsive post-image&#34;&gt;
  

&lt;p&gt;這次的 rust-52-projects 系列帶來了 &lt;code&gt;media-metadata-explorer&lt;/code&gt;——一個能深入剖析影音檔案內部結構的 CLI 工具。它透過 FFmpeg 的 &lt;code&gt;libavformat&lt;/code&gt; 函式庫讀取媒體容器資訊，同時還做了一件很有趣的事：附帶了一個 &lt;code&gt;libavformat-ffi&lt;/code&gt; companion crate，示範三種不同的 Rust FFI 呼叫方式（詳見&lt;a href=&#34;https://blog.simplypatrick.com/posts/2026/01-17-ffi-comparison&#34;&gt;之前的 FFI 比較文章&lt;/a&gt;）。&lt;/p&gt;
&lt;p&gt;這篇文章會聚焦在工具本身的設計——三個實用的 CLI 子命令，以及用 &lt;code&gt;crossterm&lt;/code&gt; 打造互動式 TUI 的過程。&lt;/p&gt;
&lt;h3 id=&#34;專案功能概覽&#34;&gt;專案功能概覽&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;media-metadata-explorer&lt;/code&gt; 提供三個子命令，對應三種使用情境：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;inspect &amp;lt;file&amp;gt; [--json]&lt;/code&gt;&lt;/strong&gt; 是最基本的單檔檢視模式。打開一個 &lt;code&gt;.mkv&lt;/code&gt; 或 &lt;code&gt;.mp3&lt;/code&gt;，它會列出容器格式名稱、總時長、檔案大小、位元率、容器層級的 metadata 標籤（如 title、encoder），以及每條串流的詳細資訊：影片串流會顯示解析度與幀率，音訊串流則顯示取樣率、聲道數、語言標籤等。加上 &lt;code&gt;--json&lt;/code&gt; 旗標可以輸出結構化的 &lt;code&gt;MediaReport&lt;/code&gt;，方便接到其他工具做二次處理。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;catalog &amp;lt;dir&amp;gt; [--recursive] [--json]&lt;/code&gt;&lt;/strong&gt; 是媒體庫整理利器。它會走訪目錄，篩選 &lt;code&gt;mp4&lt;/code&gt;、&lt;code&gt;mkv&lt;/code&gt;、&lt;code&gt;mov&lt;/code&gt;、&lt;code&gt;avi&lt;/code&gt;、&lt;code&gt;webm&lt;/code&gt;、&lt;code&gt;mp3&lt;/code&gt;、&lt;code&gt;flac&lt;/code&gt;、&lt;code&gt;wav&lt;/code&gt; 等常見副檔名，逐一探測後彙整成 &lt;code&gt;CatalogReport&lt;/code&gt;：總時長、容器格式出現頻率（依次排序）、編解碼器統計，以及探測失敗的檔案清單。有個小細節：FFmpeg 回傳的格式名稱常常是 &lt;code&gt;&amp;quot;mov,mp4,m4a,3gp,3g2,mj2&amp;quot;&lt;/code&gt; 這樣一串，程式只取第一個 token，讓統計結果更好讀。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;tui &amp;lt;file&amp;gt; [--max-packets N]&lt;/code&gt;&lt;/strong&gt; 則是整個專案最有趣的部分——互動式終端瀏覽器，下一節細說。&lt;/p&gt;
&lt;h3 id=&#34;tui-設計用-crossterm-打造終端介面&#34;&gt;TUI 設計：用 crossterm 打造終端介面&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;tui&lt;/code&gt; 子命令會先讀取最多 N 個封包（預設 2000），在記憶體中建立一棵樹，再用 &lt;code&gt;crossterm&lt;/code&gt; 啟動全螢幕互動介面。&lt;/p&gt;
&lt;p&gt;樹狀結構分三個頂層節點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Container Info&lt;/strong&gt;：格式名稱、時長、位元率、檔案大小、metadata 標籤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Streams&lt;/strong&gt;：每條串流展開後顯示編解碼器參數、串流標籤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Packets&lt;/strong&gt;：依串流索引分群，每個封包顯示 PTS、DTS、大小、是否為關鍵幀&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;導覽鍵支援 Vim 風格（&lt;code&gt;j&lt;/code&gt;/&lt;code&gt;k&lt;/code&gt; 上下、&lt;code&gt;h&lt;/code&gt;/&lt;code&gt;l&lt;/code&gt; 收合/展開）以及方向鍵、PageUp/PageDown、Home/End。Space 切換展開狀態，&lt;code&gt;q&lt;/code&gt; 或 Esc 退出。顏色區分不同節點類型：cyan 是標題、magenta 是容器資訊、blue 是串流節點、green 是封包節點、yellow 是標籤值。&lt;/p&gt;
&lt;h4 id=&#34;crossterm-的角色&#34;&gt;crossterm 的角色&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;crossterm&lt;/code&gt; 是 Rust 生態系裡最常見的跨平台終端控制函式庫，名字裡的 &amp;ldquo;cross&amp;rdquo; 就是這個意思——同一套 API 可以在 Windows、macOS、Linux 上跑，不用自己處理 ANSI escape code 或 Windows Console API 的差異。&lt;/p&gt;
&lt;p&gt;它的 API 設計圍繞著「命令（command）」的概念，每個動作都是一個實作 &lt;code&gt;Command&lt;/code&gt; trait 的型別：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; crossterm::{
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    cursor::{Hide, MoveTo, Show},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    event::{self, Event, KeyCode},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    style::{Color, Print, ResetColor, SetBackgroundColor, SetForegroundColor},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    terminal::{self, Clear, ClearType, EnterAlternateScreen, LeaveAlternateScreen},
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;執行命令有兩個 macro：&lt;code&gt;execute!&lt;/code&gt; 會立刻寫入並 flush，&lt;code&gt;queue!&lt;/code&gt; 只是把命令放進緩衝區。TUI 的 render 函式全程用 &lt;code&gt;queue!&lt;/code&gt; 積攢所有繪製動作，最後才呼叫一次 &lt;code&gt;out.flush()&lt;/code&gt;——這樣終端只會看到一個完整畫面，不會因為部分更新而閃爍：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;queue!&lt;/span&gt;(out, MoveTo(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;), Clear(ClearType::All))&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// ... 積攢所有列的繪製命令 ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;out.flush()&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;  &lt;span style=&#34;color:#75715e&#34;&gt;// 一次送出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;進入 TUI 之前，程式需要做三件準備工作：啟用 &lt;strong&gt;raw mode&lt;/strong&gt;（讓按鍵立刻送達、不等換行、不回顯到螢幕）、切換到 &lt;strong&gt;alternate screen&lt;/strong&gt;（保留原本的終端內容，退出後可以還原）、以及隱藏游標。這三步統一在 &lt;code&gt;TerminalGuard::enter()&lt;/code&gt; 裡完成，&lt;code&gt;Drop&lt;/code&gt; 時反向還原：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;enter&lt;/span&gt;(out: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Stdout) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Self&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    terminal::enable_raw_mode()&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;execute!&lt;/span&gt;(out, EnterAlternateScreen, Hide)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(Self)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;impl&lt;/span&gt; Drop &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; TerminalGuard {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;drop&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; terminal::disable_raw_mode();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; _ &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;execute!&lt;/span&gt;(stdout(), Show, LeaveAlternateScreen);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;事件迴圈用 &lt;code&gt;event::read()&lt;/code&gt; 阻塞等待下一個事件，&lt;code&gt;Event::Key&lt;/code&gt; 處理按鍵，&lt;code&gt;Event::Resize&lt;/code&gt; 處理視窗大小改變。Resize 事件不需要任何邏輯——只要設 &lt;code&gt;dirty = true&lt;/code&gt;，下一個 frame 就會用新的 &lt;code&gt;terminal::size()&lt;/code&gt; 重繪，自然就適應了新的寬高。&lt;/p&gt;
&lt;h4 id=&#34;三層資料結構設計&#34;&gt;三層資料結構設計&lt;/h4&gt;
&lt;p&gt;TUI 的樹狀結構採用了一個乾淨的三層分離設計。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第一層：&lt;code&gt;TreeNode&lt;/code&gt;（資料層）&lt;/strong&gt;&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TreeNode&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    id: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    label: String,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    children: Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;TreeNode&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這是一棵遞迴的 owned tree，&lt;code&gt;children&lt;/code&gt; 直接擁有子節點，不用指標也不用 &lt;code&gt;Rc&lt;/code&gt;。每個節點的 &lt;code&gt;id&lt;/code&gt; 由建構時的 &lt;code&gt;&amp;amp;mut usize&lt;/code&gt; counter 遞增分配，全域唯一。&lt;strong&gt;這棵樹只管結構，完全不知道展開/收合狀態。&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第二層：&lt;code&gt;TreeState&lt;/code&gt;（狀態層）&lt;/strong&gt;&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;TreeState&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    selected: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,          &lt;span style=&#34;color:#75715e&#34;&gt;// 游標在第幾行（flat index）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    scroll: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,            &lt;span style=&#34;color:#75715e&#34;&gt;// viewport 捲動偏移
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expanded: &lt;span style=&#34;color:#a6e22e&#34;&gt;BTreeSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, &lt;span style=&#34;color:#75715e&#34;&gt;// 哪些 node_id 目前是展開的
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;展開狀態完全分離在 &lt;code&gt;BTreeSet&amp;lt;node_id&amp;gt;&lt;/code&gt; 裡，不碰 &lt;code&gt;TreeNode&lt;/code&gt; 本身。要展開一個節點就 &lt;code&gt;insert(id)&lt;/code&gt;，要收合就 &lt;code&gt;remove(id)&lt;/code&gt;，操作極其簡單。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;第三層：&lt;code&gt;FlatLine&lt;/code&gt;（視圖層）&lt;/strong&gt;&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FlatLine&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    node_id: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    label: String,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    depth: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    has_children: &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    expanded: &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次重繪前，&lt;code&gt;flatten_tree()&lt;/code&gt; 遍歷 &lt;code&gt;TreeNode&lt;/code&gt;、搭配 &lt;code&gt;expanded&lt;/code&gt; set，產生「目前可見行」的扁平 &lt;code&gt;Vec&amp;lt;FlatLine&amp;gt;&lt;/code&gt;。如果一個節點的 id 不在 &lt;code&gt;expanded&lt;/code&gt; 裡，它的子節點就不會被加入——視覺上就「消失」了：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;flatten_tree&lt;/span&gt;(node: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;TreeNode&lt;/span&gt;, expanded_ids: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;BTreeSet&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, depth: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;, out: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;mut&lt;/span&gt; Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;FlatLine&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; expanded &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; expanded_ids.contains(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;node.id);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    out.push(FlatLine { node_id: &lt;span style=&#34;color:#a6e22e&#34;&gt;node&lt;/span&gt;.id, label: &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;., depth, has_children: &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;., expanded });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; has_children &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; expanded {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; child &lt;span style=&#34;color:#66d9ef&#34;&gt;in&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;node.children {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            flatten_tree(child, expanded_ids, depth &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;, out);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;這是典型的 &lt;strong&gt;document-view 分離&lt;/strong&gt;：&lt;code&gt;TreeNode&lt;/code&gt; 是不可變的文件結構，一次建立後不再修改；&lt;code&gt;TreeState.expanded&lt;/code&gt; 是可變的互動狀態；&lt;code&gt;Vec&amp;lt;FlatLine&amp;gt;&lt;/code&gt; 則是每個 render frame 重新推導的視圖，不需要維護反向指標。&lt;code&gt;selected&lt;/code&gt; 和 &lt;code&gt;scroll&lt;/code&gt; 追蹤的是 flat list 的 index，不是 &lt;code&gt;node_id&lt;/code&gt;，因為鍵盤導覽只關心「螢幕上第幾行」。&lt;/p&gt;
&lt;p&gt;實作上有幾個設計值得一提：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Dirty flag 避免不必要重繪。&lt;/strong&gt; TUI 的事件迴圈維護一個 &lt;code&gt;dirty: bool&lt;/code&gt;，只有真正改變畫面狀態的按鍵（移動選取、展開/收合、視窗 resize）才設 &lt;code&gt;dirty = true&lt;/code&gt;，下一個迴圈才重繪。這比每個 tick 無條件清屏再重畫要省 CPU，也避免畫面閃爍。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;&lt;code&gt;TerminalGuard&lt;/code&gt; 確保終端狀態復原。&lt;/strong&gt; 進入 TUI 前需要切換到 alternate screen、啟用 raw mode、隱藏游標。為了確保不論正常退出還是 panic，終端都能恢復正常，程式定義了一個零大小的 &lt;code&gt;TerminalGuard&lt;/code&gt; struct，在 &lt;code&gt;Drop&lt;/code&gt; 裡執行清理動作（disable raw mode、show cursor、leave alternate screen）。這是 Rust RAII 慣用法的典型應用。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Parent 節點搜尋是 O(n) 的線性掃描。&lt;/strong&gt; 當使用者按 &lt;code&gt;h&lt;/code&gt; 要跳到父節點時，程式從當前行往上掃，找第一個 &lt;code&gt;depth == current_depth - 1&lt;/code&gt; 的行。雖然理論上是 O(n)，但實際上樹的深度有限、總行數也不多，這個簡單實作完全夠用，不需要額外維護父節點指標。&lt;/p&gt;
&lt;h3 id=&#34;開發心得與踩坑記錄&#34;&gt;開發心得與踩坑記錄&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;BTreeMap 讓輸出穩定有序。&lt;/strong&gt; 容器和串流的 metadata 標籤改用 &lt;code&gt;BTreeMap&amp;lt;String, String&amp;gt;&lt;/code&gt; 而非 &lt;code&gt;HashMap&lt;/code&gt;，好處是不論 JSON 輸出還是 TUI 顯示，標籤永遠按字母順序排列，不會因 hash 隨機性產生不穩定的輸出。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;FFmpeg 的「不知道」值要小心處理。&lt;/strong&gt; FFmpeg 大量使用 &lt;code&gt;0&lt;/code&gt; 或 &lt;code&gt;-1&lt;/code&gt; 表示「未知/不可用」。程式定義了 &lt;code&gt;to_u64(i64) -&amp;gt; Option&amp;lt;u64&amp;gt;&lt;/code&gt; 和 &lt;code&gt;to_u32(i32) -&amp;gt; Option&amp;lt;u32&amp;gt;&lt;/code&gt; 兩個轉換幫手，把 0 和負值都變成 &lt;code&gt;None&lt;/code&gt;，對外 API 就能乾淨地用 &lt;code&gt;Option&lt;/code&gt; 表達可選欄位，不用每次都檢查魔法數值。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;EOF 的位元運算。&lt;/strong&gt; FFmpeg 用負數的四字元碼表示 EOF 錯誤（&lt;code&gt;AVERROR_EOF = -((&#39;E&#39; | &#39;O&#39;&amp;lt;&amp;lt;8 | &#39;F&#39;&amp;lt;&amp;lt;16 | &#39; &#39;&amp;lt;&amp;lt;24))&lt;/code&gt;）。Rust 端重建這個常數的方式和 C 端一樣，不依賴外部匯入的常數，讓 EOF 和真正的讀取錯誤可以明確區分。第一次看到這個寫法還楞了一下，仔細想才明白這是 FFmpeg 的 FOURCC 慣例。&lt;/p&gt;
&lt;p&gt;整體而言，這個專案把「實用工具」和「教學示範」結合得很好——&lt;code&gt;media-metadata-explorer&lt;/code&gt; 本身就是個可以日常使用的媒體檔案檢視器，而 &lt;code&gt;libavformat-ffi&lt;/code&gt; companion crate 則是學習 Rust FFI 的絕佳參考資料。&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>
