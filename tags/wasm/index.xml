<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Simply Patrick </title>
    <link>https://blog.simplypatrick.com/tags/wasm/</link>
    <author>Patrick Tsai</author>
    <rights>Copyright (c) 2003 - 2016, Patrick Tsai; all rights reserved.</rights>
    <updated>2026-02-15 10:00:00 &#43;0800 &#43;0800</updated>
    
    <item>
      <title>TileSplit WASM：把 Ultra HDR 圖片切割搬到瀏覽器</title>
      <link>https://blog.simplypatrick.com/posts/2026/02-15-tilesplit-wasm/</link>
      <pubDate>Sun, 15 Feb 2026 10:00:00 &#43;0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/posts/2026/02-15-tilesplit-wasm/</guid>
      <description>&lt;p&gt;&lt;a href=&#34;https://blog.simplypatrick.com/posts/2026/02-14-tilesplit/&#34;&gt;上一篇&lt;/a&gt;介紹了 &lt;code&gt;tilesplit&lt;/code&gt; CLI，一個用 Rust 寫的工具，可以在切割圖片的同時保留 Ultra HDR 資訊。但要用 CLI 切個照片還得先裝 Rust 工具鏈&amp;hellip; 不如直接在瀏覽器裡搞定？&lt;/p&gt;
&lt;p&gt;這篇就來聊聊怎麼把 &lt;code&gt;tilesplit&lt;/code&gt; 移植到 WebAssembly，讓任何人&lt;a href=&#34;https://blog.simplypatrick.com/demos/tilesplit/&#34;&gt;打開網頁&lt;/a&gt;就能用。&lt;/p&gt;
&lt;h2 id=&#34;先玩再說&#34;&gt;先玩再說&lt;/h2&gt;
&lt;iframe src=&#34;https://blog.simplypatrick.com/demos/tilesplit/&#34; style=&#34;width: 100%; height: 730px; border: 1px solid #333; border-radius: 8px; background: #0f1117;&#34; loading=&#34;lazy&#34;&gt;&lt;/iframe&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;使用方式&lt;/strong&gt;：拖一張 JPEG 進去（支援 3:2 或 16:10 比例），調整品質後按 Split。如果是 Ultra HDR 照片，會自動偵測並顯示 HDR 標籤。切完的圖可以直接下載。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;從-cli-到-wasm關鍵差異&#34;&gt;從 CLI 到 WASM：關鍵差異&lt;/h2&gt;
&lt;p&gt;把 &lt;code&gt;tilesplit&lt;/code&gt; 搬到瀏覽器不是改個編譯目標就完事的。最大的挑戰在於&lt;strong&gt;依賴庫的替換&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;CLI 版本用了兩個 C/C++ FFI 的 crate：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;ultrahdr-rs&lt;/code&gt;&lt;/strong&gt;：Google &lt;code&gt;libultrahdr&lt;/code&gt; 的封裝，處理 Ultra HDR 的編解碼和容器組裝&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;jpegli-rs&lt;/code&gt;&lt;/strong&gt;：Google &lt;code&gt;jpegli&lt;/code&gt; 的封裝，高品質 JPEG 編解碼器，支援讀寫 Gain Map&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;問題是：&lt;strong&gt;WASM 沒辦法呼叫 C FFI&lt;/strong&gt;。這兩個 crate 都需要編譯 C/C++ 原始碼，在 &lt;code&gt;wasm32-unknown-unknown&lt;/code&gt; 目標下根本編不過。&lt;/p&gt;
&lt;p&gt;WASM 版本的替代方案：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;功能&lt;/th&gt;
          &lt;th&gt;CLI 版本&lt;/th&gt;
          &lt;th&gt;WASM 版本&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;JPEG 編解碼&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;jpegli-rs&lt;/code&gt; (C FFI)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;image&lt;/code&gt; crate (純 Rust)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Ultra HDR metadata&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;ultrahdr-rs&lt;/code&gt; (C FFI)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;ultrahdr-core&lt;/code&gt; (純 Rust)&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;容器組裝&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;ultrahdr-rs&lt;/code&gt; 的 &lt;code&gt;add_gainmap()&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;手動組裝 MPF 格式&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;a href=&#34;https://crates.io/crates/ultrahdr-core&#34;&gt;&lt;code&gt;ultrahdr-core&lt;/code&gt;&lt;/a&gt; 是個輕量的純 Rust crate，只做 metadata 解析和 XMP 生成，不碰任何 C 程式碼——正好適合 WASM。而 &lt;a href=&#34;https://crates.io/crates/image&#34;&gt;&lt;code&gt;image&lt;/code&gt;&lt;/a&gt; crate 的 JPEG 功能雖然沒有 &lt;code&gt;jpegli&lt;/code&gt; 那麼強，但對我們的需求來說夠用了。&lt;/p&gt;
&lt;p&gt;最麻煩的是容器組裝。CLI 版本靠 &lt;code&gt;jpegli-rs&lt;/code&gt; 的 &lt;code&gt;.add_gainmap()&lt;/code&gt; 一行搞定，但 WASM 版本得自己手動把 XMP marker、MPF header、Gain Map JPEG 按照正確的格式塞回主圖裡。這部分後面會詳細說明。&lt;/p&gt;
&lt;h2 id=&#34;wasm-api-設計&#34;&gt;WASM API 設計&lt;/h2&gt;
&lt;p&gt;WASM 模組只暴露三個函式給 JavaScript：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_image&lt;/span&gt;(data: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;JsValue, JsValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    console_error_panic_hook::set_once();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; img &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; image::load_from_memory(data)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .map_err(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;e&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; JsValue::from_str(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;format!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Failed to decode image: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{e}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)))&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (width, height) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (img.width(), img.height());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; is_ultra_hdr &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; detect_ultrahdr(data).is_some();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (left, _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; compute_split_rectangles(width, height)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .map_err(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;e&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; JsValue::from_str(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;e))&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; info &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ImageInfo { width, height, &lt;span style=&#34;color:#75715e&#34;&gt;/* ... */&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    serde_wasm_bindgen::to_value(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;info)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .map_err(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;e&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; JsValue::from_str(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;format!&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Serialization error: &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;{e}&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;split_left&lt;/span&gt;(data: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;], quality: &lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, JsValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    console_error_panic_hook::set_once();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    split_tile(data, quality, Side::Left).map_err(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;e&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; JsValue::from_str(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;e))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;split_right&lt;/span&gt;(data: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;], quality: &lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, JsValue&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    console_error_panic_hook::set_once();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    split_tile(data, quality, Side::Right).map_err(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;e&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; JsValue::from_str(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;e))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;回傳給 JS 的 &lt;code&gt;ImageInfo&lt;/code&gt; 用 &lt;code&gt;serde&lt;/code&gt; 序列化成 JS object：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[derive(Serialize)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ImageInfo&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    width: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    height: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    aspect: String,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#[serde(rename = &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;isUltraHdr&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    is_ultra_hdr: &lt;span style=&#34;color:#66d9ef&#34;&gt;bool&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#[serde(rename = &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tileWidth&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tile_width: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;#[serde(rename = &lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;tileHeight&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    tile_height: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;資料流很直覺：JS 透過 &lt;code&gt;FileReader&lt;/code&gt; 讀取使用者選的檔案，轉成 &lt;code&gt;Uint8Array&lt;/code&gt; 傳進 WASM，WASM 處理完回傳 &lt;code&gt;Vec&amp;lt;u8&amp;gt;&lt;/code&gt;（自動轉成 &lt;code&gt;Uint8Array&lt;/code&gt;），JS 再包成 Blob URL 給 &lt;code&gt;&amp;lt;img&amp;gt;&lt;/code&gt; 顯示和下載。&lt;/p&gt;
&lt;h2 id=&#34;ultra-hdr-偵測&#34;&gt;Ultra HDR 偵測&lt;/h2&gt;
&lt;p&gt;WASM 版本的 Ultra HDR 偵測是直接解析 JPEG 的二進制結構，不靠任何外部庫的 JPEG 解碼器：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;detect_ultrahdr&lt;/span&gt;(data: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;]) -&amp;gt; Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;UltraHdrData&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 從 JPEG 的 APP1 marker 裡撈出 XMP metadata
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; xmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; extract_xmp_from_jpeg_bytes(data)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 解析 XMP 得到 GainMapMetadata
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; metadata, _) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ultrahdr_core::metadata::xmp::parse_xmp(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;xmp).ok()&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 從 MPF (Multi-Picture Format) 裡提取 Gain Map JPEG
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; gainmap_jpeg &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; extract_gainmap_from_mpf(data)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 主圖的 metadata 可能不完整，試試從 Gain Map 自己的 XMP 補齊
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; metadata_looks_default_or_incomplete(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;metadata) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Some(gm_xmp) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; extract_xmp_from_jpeg_bytes(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gainmap_jpeg) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; Ok((&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; gm_meta, _)) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ultrahdr_core::metadata::xmp::parse_xmp(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gm_xmp) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                apply_lenient_xmp_overrides(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gm_xmp, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; gm_meta);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;metadata_looks_default_or_incomplete(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gm_meta) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                    metadata &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gm_meta;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;                }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    apply_lenient_xmp_overrides(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;xmp, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; metadata);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Some(UltraHdrData { metadata, gainmap_jpeg })
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;跟 CLI 版本比起來，最大的差異是 XMP 提取。CLI 版本靠 &lt;code&gt;jpegli&lt;/code&gt; 解碼器順便把 XMP 和 Gain Map 從 JPEG extras 裡讀出來。WASM 版本沒有 &lt;code&gt;jpegli&lt;/code&gt;，只好自己掃描 JPEG marker——找 &lt;code&gt;0xFFE1&lt;/code&gt; (APP1) 拿 XMP，再用 &lt;code&gt;ultrahdr-core&lt;/code&gt; 的 MPF parser 找 Gain Map 的位置。&lt;/p&gt;
&lt;h2 id=&#34;手動組裝-ultra-hdr-容器&#34;&gt;手動組裝 Ultra HDR 容器&lt;/h2&gt;
&lt;p&gt;這是 WASM 移植裡最複雜的部分。CLI 版本一行 &lt;code&gt;.add_gainmap()&lt;/code&gt; 就搞定的事，在 WASM 版本得手動處理 MPF (Multi-Picture Format) 的二進制結構。&lt;/p&gt;
&lt;p&gt;一張 Ultra HDR JPEG 的結構大概長這樣：&lt;/p&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────┐
│ SOI (0xFFD8)                    │
│ APP1 - XMP metadata             │  ← 告訴系統「我是 Ultra HDR」
│ APP2 - MPF header               │  ← 告訴系統「Gain Map 在哪裡」
│ ... 正常的 JPEG 資料 ...         │
│ EOI (0xFFD9)                    │
├─────────────────────────────────┤
│ Gain Map JPEG (完整的第二張圖)   │  ← 亮度增益資訊
└─────────────────────────────────┘&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;assemble_ultrahdr_tile&lt;/code&gt; 函式負責把這些東西拼在一起：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;assemble_ultrahdr_tile&lt;/span&gt;(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    sdr_jpeg: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    gainmap_jpeg: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;[&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;],
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    metadata: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;GainMapMetadata&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;) -&amp;gt; Result&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Vec&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;u8&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;, String&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 1. 在 Gain Map JPEG 裡嵌入 XMP metadata
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; gainmap_xmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_gainmap_xmp(metadata);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; gainmap_jpeg_with_xmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; embed_xmp_in_jpeg(gainmap_jpeg, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gainmap_xmp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 2. 產生主圖的 XMP APP1 marker（包含完整參數 + Container directory）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; xmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; generate_primary_xmp(metadata, gainmap_jpeg_with_xmp.len());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; xmp_marker &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; ultrahdr_core::metadata::xmp::create_xmp_app1_marker(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;xmp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 3. 把 XMP 插到 SOI 後面
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; primary_with_xmp &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Vec::with_capacity(sdr_jpeg.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; xmp_marker.len());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    primary_with_xmp.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sdr_jpeg[&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]); &lt;span style=&#34;color:#75715e&#34;&gt;// SOI
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    primary_with_xmp.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;xmp_marker);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    primary_with_xmp.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;sdr_jpeg[&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 4. 找到插入 MPF APP2 的位置（在 APP0/APP1 之後）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; insert_pos &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; find_mpf_insert_position(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;primary_with_xmp)&lt;span style=&#34;color:#f92672&#34;&gt;?&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 5. 計算 MPF header（需要知道最終的 primary 大小，所以先算一次）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; gm_len &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; gainmap_jpeg_with_xmp.len() &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; placeholder_mpf &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; create_mpf_app2(&lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;::&lt;span style=&#34;color:#66d9ef&#34;&gt;MAX&lt;/span&gt;, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;[gm_len], insert_pos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; primary_final_size &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (primary_with_xmp.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; placeholder_mpf.len()) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; mpf_header &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; create_mpf_app2(primary_final_size, &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;[gm_len], insert_pos);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 6. 組裝最終輸出
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Vec::with_capacity(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        primary_with_xmp.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; mpf_header.len() &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; gainmap_jpeg_with_xmp.len()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    );
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    output.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;primary_with_xmp[&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;insert_pos]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    output.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;mpf_header);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    output.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;primary_with_xmp[insert_pos&lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;]);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    output.extend_from_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;gainmap_jpeg_with_xmp);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    Ok(output)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;MPF header 裡面是個迷你的 TIFF IFD 結構，記錄了每張圖片的大小和偏移量。這裡有個雞生蛋的問題：MPF header 裡需要填 primary 的最終大小，但 primary 的大小又取決於 MPF header 有多大。解法是先用 placeholder 算出 MPF 的固定大小，再用正確的數值重新生成。&lt;/p&gt;
&lt;h2 id=&#34;wasm-體積優化&#34;&gt;WASM 體積優化&lt;/h2&gt;
&lt;p&gt;WASM 版本最終編出來的 &lt;code&gt;.wasm&lt;/code&gt; 檔案大約 &lt;strong&gt;286 KB&lt;/strong&gt;，對一個包含完整 JPEG 編解碼和 Ultra HDR 處理的模組來說算很小了。主要靠幾個手段：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;profile&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;release&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;opt-level&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s&amp;#34;&lt;/span&gt;   &lt;span style=&#34;color:#75715e&#34;&gt;# 優化體積而非速度&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lto&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;# 跨 crate 的 Link-Time Optimization&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;加上 &lt;code&gt;image&lt;/code&gt; crate 只啟用 &lt;code&gt;jpeg&lt;/code&gt; feature，不拉進 PNG、GIF 等不需要的格式：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;dependencies&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;image&lt;/span&gt; = { &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.25.5&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;default-features&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;false&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;features&lt;/span&gt; = [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;jpeg&amp;#34;&lt;/span&gt;] }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;default-features = false&lt;/code&gt; 很重要——&lt;code&gt;image&lt;/code&gt; crate 預設會拉進一大堆圖片格式的支援，對 WASM 體積影響很大。&lt;/p&gt;
&lt;h2 id=&#34;js-端的整合&#34;&gt;JS 端的整合&lt;/h2&gt;
&lt;p&gt;前端部分很簡單，用原生的 ES module 載入 WASM：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;, { &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_image&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;split_left&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;split_right&lt;/span&gt; } &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;./tilesplit_wasm.js&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;();  &lt;span style=&#34;color:#75715e&#34;&gt;// 載入並初始化 WASM 模組
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;console&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;log&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;TileSplit WASM loaded&amp;#39;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;();&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;wasm-pack build --target web&lt;/code&gt; 產生的 JS glue code 會自動處理 WASM 的載入和記憶體管理。&lt;code&gt;init()&lt;/code&gt; 內部用 &lt;code&gt;WebAssembly.instantiateStreaming&lt;/code&gt; 做串流載入，瀏覽器可以在下載 WASM 的同時開始編譯，體驗很流暢。&lt;/p&gt;
&lt;p&gt;圖片處理的流程：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 使用者選擇檔案後
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;FileReader&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;onload&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;) =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Uint8Array&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;e&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;target&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;result&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;info&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;validate_image&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;data&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// WASM 驗證
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 顯示圖片資訊...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;reader&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;readAsArrayBuffer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;file&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 按下 Split 後
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;leftBytes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;split_left&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;quality&lt;/span&gt;);   &lt;span style=&#34;color:#75715e&#34;&gt;// WASM 切割
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;rightBytes&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;split_right&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;currentData&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;quality&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;leftBlob&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Blob&lt;/span&gt;([&lt;span style=&#34;color:#a6e22e&#34;&gt;leftBytes&lt;/span&gt;], { &lt;span style=&#34;color:#a6e22e&#34;&gt;type&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;image/jpeg&amp;#39;&lt;/span&gt; });
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;previewLeft&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;src&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;URL&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createObjectURL&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;leftBlob&lt;/span&gt;);       &lt;span style=&#34;color:#75715e&#34;&gt;// 顯示預覽
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;整個過程都在瀏覽器本地完成，圖片不會上傳到任何伺服器。&lt;/p&gt;
&lt;h3 id=&#34;小結&#34;&gt;小結&lt;/h3&gt;
&lt;p&gt;Ultra HDR 的「正確」其實散落在規格的各個角落。光看 &lt;a href=&#34;https://www.iso.org/standard/81379.html&#34;&gt;ISO 21496-1&lt;/a&gt; 規格書不夠，得拿 Lightroom、Google Photos 等軟體的實際輸出來對照，才能確定哪些欄位是必要的、viewer 實際上怎麼解析。&lt;/p&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;把 Rust CLI 工具移植到 WASM 最大的收穫是：&lt;strong&gt;降低了使用門檻&lt;/strong&gt;。不需要安裝任何東西，打開網頁就能用。對於像 &lt;code&gt;tilesplit&lt;/code&gt; 這種偶爾才用一次的小工具，WASM 版本可能比 CLI 更實用。&lt;/p&gt;
&lt;p&gt;當然也有取捨——WASM 版本用的 &lt;code&gt;image&lt;/code&gt; crate JPEG 編碼器品質沒有 &lt;code&gt;jpegli&lt;/code&gt; 好，處理速度也稍慢一些。但對於「切一張照片發 IG」這個使用情境來說，完全夠用。&lt;/p&gt;
&lt;p&gt;完整程式碼在 &lt;a href=&#34;https://github.com/p47t/rust-52-projects/tree/main/tilesplit-wasm&#34;&gt;GitHub&lt;/a&gt; 上。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>WASM 裡的 Rust Async 沒有 Runtime</title>
      <link>https://blog.simplypatrick.com/tils/2026/2026-02-10-rust-wasm-async-runtime/</link>
      <pubDate>Tue, 10 Feb 2026 00:00:00 UTC</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/tils/2026/2026-02-10-rust-wasm-async-runtime/</guid>
      <description>&lt;p&gt;在做 &lt;a href=&#34;https://blog.simplypatrick.com/posts/2026/02-09-wgpu-game-of-life/&#34;&gt;wgpu Game of Life&lt;/a&gt; 時發現一件事：WASM 環境下的 Rust async 不需要 Tokio 或 async-std——&lt;strong&gt;瀏覽器的 event loop 就是 runtime&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;在 native Rust，你需要一個 executor 來 poll futures。但在 WASM，&lt;code&gt;wasm-bindgen-futures&lt;/code&gt; 把 Rust 的 &lt;code&gt;Future&lt;/code&gt; 轉換成 JavaScript 的 &lt;code&gt;Promise&lt;/code&gt;，交給瀏覽器的 event loop 來驅動：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(canvas_id: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 每個 .await 都是把控制權交還給瀏覽器的 event loop
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; adapter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; instance.request_adapter(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;options).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (device, queue) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; adapter.request_device(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;desc, None).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;JavaScript 端看到的就是一個回傳 &lt;code&gt;Promise&lt;/code&gt; 的函式：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wasm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;canvas&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次 &lt;code&gt;.await&lt;/code&gt; 時，Rust future 暫停執行，控制權回到瀏覽器。當底層的 JS 操作（例如 WebGPU 的 &lt;code&gt;requestAdapter&lt;/code&gt;）完成時，瀏覽器透過 microtask 觸發 Rust 的 waker，從暫停處繼續執行。&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;Native&lt;/th&gt;
          &lt;th&gt;WASM&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;Runtime&lt;/td&gt;
          &lt;td&gt;Tokio / async-std&lt;/td&gt;
          &lt;td&gt;瀏覽器 event loop&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Executor&lt;/td&gt;
          &lt;td&gt;Rust 端的 thread pool&lt;/td&gt;
          &lt;td&gt;JS microtask queue&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;Spawn&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;tokio::spawn&lt;/code&gt;（多執行緒）&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;spawn_local&lt;/code&gt;（單執行緒）&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;所以 &lt;code&gt;Cargo.toml&lt;/code&gt; 只需要 &lt;code&gt;wasm-bindgen-futures&lt;/code&gt;，不需要任何 Rust async runtime。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>wasm-bindgen 產生的 JS 膠水程式碼在做什麼</title>
      <link>https://blog.simplypatrick.com/tils/2026/2026-02-10-wasm-bindgen-glue-code/</link>
      <pubDate>Tue, 10 Feb 2026 00:00:00 UTC</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/tils/2026/2026-02-10-wasm-bindgen-glue-code/</guid>
      <description>&lt;p&gt;看了 &lt;code&gt;wasm-pack build --target web&lt;/code&gt; 產生的 &lt;code&gt;pkg/&lt;/code&gt; 目錄，搞懂了 JS 膠水程式碼的角色。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;wasm-pack&lt;/code&gt; 輸出四個檔案：&lt;/p&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;檔案&lt;/th&gt;
          &lt;th&gt;用途&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;.wasm&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;編譯後的 WASM 二進位&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;.js&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;JS 膠水程式碼（&lt;strong&gt;runtime 必須&lt;/strong&gt;）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;.d.ts&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;TypeScript 型別宣告（&lt;strong&gt;純靜態，runtime 不用&lt;/strong&gt;）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;_bg.wasm.d.ts&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;原始 WASM exports 的型別宣告&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;code&gt;.d.ts&lt;/code&gt; 不參與執行——它們只給 TypeScript 編譯器做型別檢查用。整個流程不涉及 TypeScript 編譯。&lt;/p&gt;
&lt;p&gt;膠水程式碼做兩件事：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. 載入 WASM&lt;/strong&gt;：&lt;code&gt;init()&lt;/code&gt; 用 &lt;code&gt;WebAssembly.instantiateStreaming&lt;/code&gt; 串流編譯 &lt;code&gt;.wasm&lt;/code&gt; 檔，邊下載邊編譯。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 雙向橋接 WASM 和瀏覽器 API&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;JS → WASM&lt;/strong&gt;：處理型別轉換。WASM 只懂數字，所以字串要先編碼成 UTF-8 寫進 WASM 線性記憶體，再傳指標和長度：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;export&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;canvas_id&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;grid_width&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;grid_height&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ptr0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;passStringToWasm0&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;canvas_id&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;wasm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;__wbindgen_malloc&lt;/span&gt;, ...);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;len0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;WASM_VECTOR_LEN&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;wasm&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;ptr0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;len0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;grid_width&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;grid_height&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;WASM → JS&lt;/strong&gt;：&lt;code&gt;web_sys&lt;/code&gt; 的每個呼叫都對應一個 JS import 函式。以 WebGPU 的 &lt;code&gt;device.createBuffer()&lt;/code&gt; 為例，Rust 端呼叫 &lt;code&gt;web_sys&lt;/code&gt; → WASM 呼叫 import → JS 膠水程式碼呼叫真正的瀏覽器 API：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-js&#34; data-lang=&#34;js&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;__wbg_createBuffer_fb1752eab5cb2a7f&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;:&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg0&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;arg0&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;createBuffer&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;arg1&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;ret&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在 wgpu Game of Life 專案裡，膠水程式碼包含大約 200 個這樣的橋接函式，全部由 &lt;code&gt;wasm-bindgen&lt;/code&gt; 在建置時根據 &lt;code&gt;#[wasm_bindgen]&lt;/code&gt; 和 &lt;code&gt;web_sys&lt;/code&gt; 的使用自動生成。&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>用 Rust &#43; WebGPU 在瀏覽器跑 Game of Life</title>
      <link>https://blog.simplypatrick.com/posts/2026/02-09-wgpu-game-of-life/</link>
      <pubDate>Mon, 09 Feb 2026 00:00:00 -0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/posts/2026/02-09-wgpu-game-of-life/</guid>
      <description>&lt;img src=&#34;https://blog.simplypatrick.com/posts/2026/02-09-wgpu-game-of-life/featured.svg&#34; alt=&#34;featured.svg&#34; class=&#34;img-responsive post-image&#34;&gt;
  

&lt;p&gt;這個專案把 Conway&amp;rsquo;s Game of Life 搬到 GPU 上面跑——用 Rust 的 &lt;a href=&#34;https://wgpu.rs/&#34;&gt;wgpu&lt;/a&gt; 寫 WebGPU compute shader，編譯成 WASM 在瀏覽器裡執行。128x128 的網格、上萬個細胞的模擬，全部在 GPU 上平行計算。&lt;/p&gt;
&lt;p&gt;專案原始碼：&lt;a href=&#34;https://github.com/p47t/rust-52-projects/tree/master/wgpu-game-of-life&#34;&gt;wgpu-game-of-life&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;先玩再說&#34;&gt;先玩再說&lt;/h2&gt;
&lt;iframe src=&#34;https://blog.simplypatrick.com/demos/wgpu-game-of-life/&#34; style=&#34;width: 100%; height: 730px; border: 1px solid #333; border-radius: 8px; background: #0e0e18;&#34; loading=&#34;lazy&#34;&gt;&lt;/iframe&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;操作方式&lt;/strong&gt;：Play/Pause 開始模擬，點擊畫布可以畫細胞，Speed 調整速度。需要 WebGPU 支援的瀏覽器（Chrome 113+、Edge 113+、Firefox 141+）。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;顏色代表細胞年齡：綠色是新生的，黃色是年輕的，橘色是成熟的，白色是古老的 still life 結構。&lt;/p&gt;
&lt;h2 id=&#34;為什麼做這個&#34;&gt;為什麼做這個？&lt;/h2&gt;
&lt;p&gt;在完成 &lt;a href=&#34;https://blog.simplypatrick.com/posts/2026/01-06-rust-wasm-markdown-editor/&#34;&gt;WASM Markdown 編輯器&lt;/a&gt;之後，我想更深入探索 WASM 的可能性。Markdown 編輯器純粹是 CPU 計算，但現代瀏覽器已經支援 WebGPU——可以直接存取 GPU 的算力。&lt;/p&gt;
&lt;p&gt;Game of Life 是個完美的入門專案：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;天然適合平行計算&lt;/strong&gt;：每個細胞的下一代只取決於鄰居，可以完全並行&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;需要 compute shader + render pipeline&lt;/strong&gt;：同時學兩種 GPU 程式設計模式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;視覺回饋即時&lt;/strong&gt;：寫完馬上看到結果&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;規模剛好&lt;/strong&gt;：不會太大，但足以理解 GPU 程式設計的核心概念&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;技術架構&#34;&gt;技術架構&lt;/h2&gt;
&lt;h3 id=&#34;整體流程&#34;&gt;整體流程&lt;/h3&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code class=&#34;language-goat&#34; data-lang=&#34;goat&#34;&gt;[Storage Buffer A] ──read──▶ [Compute Shader] ──write──▶ [Storage Buffer B]
                                                              │
                              [Render Pipeline] ◀──read───────┘
                                    │
                              [Canvas Output]&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;核心是 &lt;strong&gt;ping-pong 雙緩衝&lt;/strong&gt;：兩個 storage buffer 交替讀寫。每一步模擬時，compute shader 從一個 buffer 讀取當前狀態，計算下一代寫入另一個 buffer，然後交換。Render pipeline 負責把結果畫到畫面上。&lt;/p&gt;
&lt;h3 id=&#34;專案結構&#34;&gt;專案結構&lt;/h3&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wgpu-game-of-life/
├── Cargo.toml
├── src/
│   ├── lib.rs           # WASM 進入點，匯出 API
│   ├── gpu.rs           # wgpu 初始化、pipeline 建立、模擬邏輯
│   ├── compute.wgsl     # Compute shader（Game of Life 規則）
│   └── render.wgsl      # Vertex + Fragment shader（網格視覺化）
├── index.html
└── www/
    ├── index.js         # 控制邏輯、動畫迴圈、滑鼠互動
    └── styles.css&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;rust-依賴項&#34;&gt;Rust 依賴項&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;dependencies&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;wgpu&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;24&amp;#34;&lt;/span&gt;                        &lt;span style=&#34;color:#75715e&#34;&gt;# WebGPU API&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;wasm-bindgen&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.2&amp;#34;&lt;/span&gt;               &lt;span style=&#34;color:#75715e&#34;&gt;# JS 互操作&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;wasm-bindgen-futures&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.4&amp;#34;&lt;/span&gt;       &lt;span style=&#34;color:#75715e&#34;&gt;# async 支援（wgpu 初始化是 async 的）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;web-sys&lt;/span&gt; = { &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.3&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;features&lt;/span&gt; = [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Document&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Window&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Element&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;HtmlCanvasElement&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;console&amp;#34;&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console_error_panic_hook&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;js-sys&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.3&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;bytemuck&lt;/span&gt; = { &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;features&lt;/span&gt; = [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;derive&amp;#34;&lt;/span&gt;] }&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;跟 Markdown 編輯器比，多了 &lt;code&gt;wgpu&lt;/code&gt;（核心）、&lt;code&gt;wasm-bindgen-futures&lt;/code&gt;（因為 GPU 初始化是非同步的）和 &lt;code&gt;bytemuck&lt;/code&gt;（安全地把 Rust 資料轉成 GPU buffer 需要的位元組）。&lt;/p&gt;
&lt;h2 id=&#34;compute-shadergame-of-life-規則&#34;&gt;Compute Shader：Game of Life 規則&lt;/h2&gt;
&lt;p&gt;這是整個專案最核心的部分——用 WGSL 寫的 compute shader：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-wgsl&#34; data-lang=&#34;wgsl&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@group&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;@binding&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;uniform&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; grid: vec2u;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@group&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;@binding&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;storage, read&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; cells_in: array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;u32&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@group&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;@binding&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;) &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;storage, read_write&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; cells_out: array&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;u32&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;@compute&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;@workgroup_size&lt;/span&gt;(&lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;8&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; main(&lt;span style=&#34;color:#a6e22e&#34;&gt;@builtin&lt;/span&gt;(global_invocation_id) id: vec3u) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (id.x &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; grid.x &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; id.y &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;=&lt;/span&gt; grid.y) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 數 8 個鄰居（環形邊界）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; neighbors: u32 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; dy: i32 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dy &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dy&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;for&lt;/span&gt; (&lt;span style=&#34;color:#66d9ef&#34;&gt;var&lt;/span&gt; dx: i32 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dx &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;; dx&lt;span style=&#34;color:#f92672&#34;&gt;++&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (dx &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; dy &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;continue&lt;/span&gt;; }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; nx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u32((i32(id.x) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dx &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i32(grid.x)) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; i32(grid.x));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; ny &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; u32((i32(id.y) &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; dy &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; i32(grid.y)) &lt;span style=&#34;color:#f92672&#34;&gt;%&lt;/span&gt; i32(grid.y));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            neighbors &lt;span style=&#34;color:#f92672&#34;&gt;+=&lt;/span&gt; select(&lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;, cells_in[cell_index(nx, ny)] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cell_index(id.x, id.y);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; cells_in[idx];
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Conway&amp;#39;s rules + 年齡追蹤
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (neighbors &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3u&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; age &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cells_out[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;;                    &lt;span style=&#34;color:#75715e&#34;&gt;// 誕生
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (age &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; (neighbors &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;2u&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;||&lt;/span&gt; neighbors &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;3u&lt;/span&gt;)) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cells_out[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; min(age &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;255u&lt;/span&gt;);   &lt;span style=&#34;color:#75715e&#34;&gt;// 存活，年齡 +1
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        cells_out[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;;                    &lt;span style=&#34;color:#75715e&#34;&gt;// 死亡
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;幾個重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;@workgroup_size(8, 8)&lt;/code&gt;&lt;/strong&gt;：每個工作群組處理 8x8 = 64 個細胞，GPU 會自動分配到各個核心&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;&lt;code&gt;cells_in&lt;/code&gt; 是唯讀，&lt;code&gt;cells_out&lt;/code&gt; 是可寫&lt;/strong&gt;：避免讀寫衝突，這就是為什麼需要兩個 buffer&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;環形邊界（toroidal wrapping）&lt;/strong&gt;：左邊超出會接到右邊，上面超出接到下面&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;年齡追蹤&lt;/strong&gt;：不只是 0/1，而是記錄細胞存活了幾代（上限 255）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;128x128 的網格需要 dispatch &lt;code&gt;ceil(128/8) × ceil(128/8) = 16 × 16 = 256&lt;/code&gt; 個工作群組，每個群組 64 個執行緒，總共 16,384 個 GPU 執行緒平行計算。&lt;/p&gt;
&lt;h2 id=&#34;render-shader年齡上色&#34;&gt;Render Shader：年齡上色&lt;/h2&gt;
&lt;p&gt;Fragment shader 根據年齡把細胞染成不同顏色：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-wgsl&#34; data-lang=&#34;wgsl&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; age_color(age: u32) -&amp;gt; vec4f {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (age &lt;span style=&#34;color:#f92672&#34;&gt;==&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0u&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; vec4f(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.06&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.06&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.12&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 死亡：深色背景
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; t &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; clamp(f32(age &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1u&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;50.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.0&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;1.0&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 顏色漸層：亮綠 → 黃綠 → 橘 → 暖白
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; c0 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec3f(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.15&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.90&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.30&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 新生
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; c1 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec3f(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.80&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.90&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.15&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 年輕
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; c2 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec3f(&lt;span style=&#34;color:#ae81ff&#34;&gt;0.95&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.60&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.10&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 成熟
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; c3 &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; vec3f(&lt;span style=&#34;color:#ae81ff&#34;&gt;1.00&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.85&lt;/span&gt;, &lt;span style=&#34;color:#ae81ff&#34;&gt;0.70&lt;/span&gt;);  &lt;span style=&#34;color:#75715e&#34;&gt;// 古老
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 三段線性插值
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (t &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.33&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mix(c0, c1, t &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.33&lt;/span&gt;); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (t &lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.66&lt;/span&gt;) { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mix(c1, c2, (t &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.33&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.33&lt;/span&gt;); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#66d9ef&#34;&gt;return&lt;/span&gt; mix(c2, c3, (t &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.66&lt;/span&gt;) &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0.34&lt;/span&gt;); }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;渲染方式是畫一個全螢幕四邊形（6 個頂點、2 個三角形），fragment shader 根據 UV 座標查詢對應的細胞年齡。這比為每個細胞生成幾何體（instanced rendering）更簡單，而且效能足夠。&lt;/p&gt;
&lt;h2 id=&#34;rust-端wgpu-初始化&#34;&gt;Rust 端：wgpu 初始化&lt;/h2&gt;
&lt;p&gt;wgpu 在 WASM 環境下的初始化跟 native 基本一樣，只是 surface 從 canvas 建立：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 從 HTML canvas 建立 surface
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; instance &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; wgpu::Instance::new(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;wgpu::InstanceDescriptor {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    backends: &lt;span style=&#34;color:#a6e22e&#34;&gt;wgpu&lt;/span&gt;::Backends::&lt;span style=&#34;color:#66d9ef&#34;&gt;BROWSER_WEBGPU&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; wgpu::Backends::&lt;span style=&#34;color:#66d9ef&#34;&gt;GL&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;Default::default()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;});
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; surface &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; instance
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .create_surface(wgpu::SurfaceTarget::Canvas(canvas))
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    .expect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;failed to create surface&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 請求 adapter 和 device（非同步）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; adapter &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; instance.request_adapter(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;wgpu::RequestAdapterOptions {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    compatible_surface: Some(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;surface),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;Default::default()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;.expect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no adapter&amp;#34;&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; (device, queue) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; adapter.request_device(
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;wgpu::DeviceDescriptor {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        required_limits: &lt;span style=&#34;color:#a6e22e&#34;&gt;wgpu&lt;/span&gt;::Limits::downlevel_webgl2_defaults()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;            .using_resolution(adapter.limits()),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#f92672&#34;&gt;..&lt;/span&gt;Default::default()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    },
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    None,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;.expect(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;no device&amp;#34;&lt;/span&gt;);&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;Backends::BROWSER_WEBGPU | Backends::GL&lt;/code&gt; 讓它在支援 WebGPU 的瀏覽器用 WebGPU，不支援的用 WebGL2 作為 fallback。&lt;/p&gt;
&lt;h3 id=&#34;ping-pong-雙緩衝&#34;&gt;Ping-Pong 雙緩衝&lt;/h3&gt;
&lt;p&gt;最有趣的設計是 bind group 的建立——為了實現 ping-pong，我們建兩組 bind group：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; compute_bind_groups &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; [
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Step 0: 讀 A，寫 B
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    create_bind_group(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cell_buffers[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cell_buffers[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// Step 1: 讀 B，寫 A
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    create_bind_group(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cell_buffers[&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;], &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;cell_buffers[&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]),
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;];&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每一步模擬只要切換 &lt;code&gt;step_index&lt;/code&gt;，就自動交換讀寫方向。&lt;/p&gt;
&lt;h2 id=&#34;wasm-api-設計&#34;&gt;WASM API 設計&lt;/h2&gt;
&lt;p&gt;Rust 端透過 &lt;code&gt;thread_local!&lt;/code&gt; 儲存全域狀態，匯出簡單的函式給 JavaScript：&lt;/p&gt;
&lt;p&gt;為什麼需要 &lt;code&gt;thread_local!&lt;/code&gt;？因為 &lt;code&gt;#[wasm_bindgen]&lt;/code&gt; 匯出的必須是自由函式，JavaScript 呼叫 &lt;code&gt;step()&lt;/code&gt;、&lt;code&gt;render()&lt;/code&gt; 時不會帶著物件——所以 &lt;code&gt;Simulation&lt;/code&gt; 必須存在模組層級的 &lt;code&gt;static&lt;/code&gt; 裡。但一般的 &lt;code&gt;static&lt;/code&gt; 要求內容必須實作 &lt;code&gt;Sync&lt;/code&gt;，而 &lt;code&gt;RefCell&lt;/code&gt; 不是 &lt;code&gt;Sync&lt;/code&gt;。&lt;code&gt;Simulation&lt;/code&gt; 裡面持有的 wgpu 資源（&lt;code&gt;Device&lt;/code&gt;、&lt;code&gt;Queue&lt;/code&gt;、&lt;code&gt;Surface&lt;/code&gt; 等）也不是 &lt;code&gt;Send&lt;/code&gt;/&lt;code&gt;Sync&lt;/code&gt; 的。&lt;code&gt;thread_local!&lt;/code&gt; 讓每個執行緒擁有自己的副本，繞過了 &lt;code&gt;Sync&lt;/code&gt; 的限制——在 WASM 環境下本來就只有一個執行緒，所以它實際上就是一個不需要 &lt;code&gt;Sync&lt;/code&gt; 的全域可變變數。&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;thread_local!&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;static&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;SIMULATION&lt;/span&gt;: &lt;span style=&#34;color:#a6e22e&#34;&gt;RefCell&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Option&lt;span style=&#34;color:#f92672&#34;&gt;&amp;lt;&lt;/span&gt;Simulation&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; RefCell::new(None);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;start&lt;/span&gt;(canvas_id: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;, grid_width: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;, grid_height: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    console_error_panic_hook::set_once();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; sim &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Simulation::new(canvas_id, grid_width, grid_height).&lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;SIMULATION&lt;/span&gt;.with(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;s.borrow_mut() &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Some(sim));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;step&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    with_sim(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;sim&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; sim.step());
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toggle_cell&lt;/span&gt;(x: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;, y: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    with_sim(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;sim&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; sim.toggle_cell(x, y));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;&lt;code&gt;start()&lt;/code&gt; 是 &lt;code&gt;async&lt;/code&gt; 的，因為 wgpu 初始化（&lt;code&gt;request_adapter&lt;/code&gt;、&lt;code&gt;request_device&lt;/code&gt;）都是非同步操作。其他函式都是同步的。&lt;/p&gt;
&lt;h3 id=&#34;cpu-端的細胞鏡像&#34;&gt;CPU 端的細胞鏡像&lt;/h3&gt;
&lt;p&gt;一個實作上的巧妙之處：我們在 CPU 端維護一份細胞狀態的副本。&lt;/p&gt;
&lt;p&gt;為什麼？因為當使用者點擊畫布要切換某個細胞時，從 GPU 讀回資料（readback）是很昂貴的操作。所以我們在 CPU 端維護一份鏡像，toggle 時修改 CPU 資料再上傳到 GPU：&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;toggle_cell&lt;/span&gt;(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; self, x: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;, y: &lt;span style=&#34;color:#66d9ef&#34;&gt;u32&lt;/span&gt;) {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; idx &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (y &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt; self.grid_width &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt; x) &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    self.cells[idx] &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; self.cells[idx] &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; { &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt; } &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt; { &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; };
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    self.queue.write_buffer(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self.cell_buffers[buf_idx], &lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        bytemuck::cast_slice(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;self.cells));
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    self.render();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;每次 &lt;code&gt;step()&lt;/code&gt; 時也同步執行 CPU 端的模擬，確保鏡像保持一致。&lt;/p&gt;
&lt;h2 id=&#34;建置與執行&#34;&gt;建置與執行&lt;/h2&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd wgpu-game-of-life
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wasm-pack build --target web
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;python -m http.server &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 開啟 http://localhost:8080&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;建置輸出：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WASM 檔案&lt;/strong&gt;：117 KB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS 膠水程式碼&lt;/strong&gt;：57 KB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;總計&lt;/strong&gt;：~174 KB&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;比 Markdown 編輯器的 235 KB 還小，主要因為 wgpu 的 WASM backend 大部分邏輯在瀏覽器原生的 WebGPU API 裡。&lt;/p&gt;
&lt;h2 id=&#34;學到的東西&#34;&gt;學到的東西&lt;/h2&gt;
&lt;h3 id=&#34;webgpu--wgpu-特定&#34;&gt;WebGPU / wgpu 特定&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Compute shader 比想像中簡單&lt;/strong&gt;：WGSL 語法接近 Rust，workgroup/dispatch 的概念很直覺&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Bind group 是關鍵抽象&lt;/strong&gt;：它定義了 shader 能存取哪些資源，切換 bind group 就能改變資料流向&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;wgpu 的跨平台設計很優秀&lt;/strong&gt;：同一份 Rust 程式碼，換個 backend 就能在 native 和 WASM 上跑&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;GPU readback 很貴&lt;/strong&gt;：不要隨便從 GPU 讀資料回來，用 CPU 鏡像是常見的解法&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;跟-markdown-編輯器的比較&#34;&gt;跟 Markdown 編輯器的比較&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;&lt;/th&gt;
          &lt;th&gt;Markdown 編輯器&lt;/th&gt;
          &lt;th&gt;Game of Life&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;GPU 使用&lt;/td&gt;
          &lt;td&gt;無&lt;/td&gt;
          &lt;td&gt;Compute + Render&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;非同步初始化&lt;/td&gt;
          &lt;td&gt;否&lt;/td&gt;
          &lt;td&gt;是（wgpu 需要 async）&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;主要瓶頸&lt;/td&gt;
          &lt;td&gt;CPU 解析&lt;/td&gt;
          &lt;td&gt;GPU shader 編譯&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;互動模式&lt;/td&gt;
          &lt;td&gt;文字輸入&lt;/td&gt;
          &lt;td&gt;滑鼠繪圖 + 動畫迴圈&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;套件大小&lt;/td&gt;
          &lt;td&gt;235 KB&lt;/td&gt;
          &lt;td&gt;174 KB&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;結語&#34;&gt;結語&lt;/h2&gt;
&lt;p&gt;這是我第一次寫 GPU shader 程式——用 Rust 配 wgpu 的體驗非常好。wgpu 把 WebGPU 的複雜性封裝得很乾淨，而 WGSL shader 語言的設計也很現代。&lt;/p&gt;
&lt;p&gt;如果你也想學 WebGPU，Game of Life 真的是個很好的起點：概念簡單、視覺效果漂亮、而且剛好涵蓋 compute pipeline 和 render pipeline 兩個核心概念。&lt;/p&gt;
&lt;h2 id=&#34;參考資源&#34;&gt;參考資源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://wgpu.rs/&#34;&gt;wgpu 官方網站&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://sotrh.github.io/learn-wgpu/&#34;&gt;Learn Wgpu 教學&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://webgpufundamentals.org/&#34;&gt;WebGPU Fundamentals&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://foo.net/projects/wgpu-life/&#34;&gt;Conway&amp;rsquo;s Game of Life using wgpu&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://github.com/scttfrdmn/webgpu-compute-exploration&#34;&gt;WebGPU Compute Exploration&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
    <item>
      <title>用 Rust 和 WebAssembly 打造即時 Markdown 編輯器</title>
      <link>https://blog.simplypatrick.com/posts/2026/01-06-rust-wasm-markdown-editor/</link>
      <pubDate>Tue, 06 Jan 2026 00:00:00 -0800</pubDate>
      <author>Patrick Tsai</author>
      <guid>https://blog.simplypatrick.com/posts/2026/01-06-rust-wasm-markdown-editor/</guid>
      <description>&lt;img src=&#34;https://blog.simplypatrick.com/posts/2026/01-06-rust-wasm-markdown-editor/featured.svg&#34; alt=&#34;featured.svg&#34; class=&#34;img-responsive post-image&#34;&gt;
  

&lt;p&gt;這個專案是我「52 個 Rust 專案」學習計畫的一部分。在完成了 16 個專案後，我發現 WebAssembly 是一個重要的學習缺口，於是決定用 Rust 來打造一個即時 Markdown 編輯器。&lt;/p&gt;
&lt;p&gt;專案原始碼：&lt;a href=&#34;https://github.com/p47t/rust-52-projects/tree/master/wasm-markdown-editor&#34;&gt;wasm-markdown-editor&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&#34;為什麼選擇這個專案&#34;&gt;為什麼選擇這個專案？&lt;/h2&gt;
&lt;p&gt;在分析了之前完成的專案後，我發現幾個學習上的空白：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;已掌握的領域&lt;/strong&gt;：Async/await、網路程式設計（TCP/UDP/HTTP/WebSockets）、解析器、CLI 工具、錯誤處理&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;待加強的領域&lt;/strong&gt;：資料庫 ORM、程序宏、FFI、&lt;strong&gt;WebAssembly&lt;/strong&gt;、進階測試、GUI/圖形&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;選擇 Markdown 編輯器的原因：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;填補關鍵缺口&lt;/strong&gt;：之前沒有任何 WASM 專案&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;善用既有技能&lt;/strong&gt;：運用之前在計算機、shell、EBML 等專案中學到的解析技巧&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;互動性強&lt;/strong&gt;：能立即看到成果，滿足感高&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;實用價值&lt;/strong&gt;：這是真正能用的工具，不只是 demo&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;現代技術棧&lt;/strong&gt;：WASM 在 Rust 生態系中越來越重要&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;技術架構&#34;&gt;技術架構&lt;/h2&gt;
&lt;h3 id=&#34;rust-依賴項&#34;&gt;Rust 依賴項&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;dependencies&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;wasm-bindgen&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.2&amp;#34;&lt;/span&gt;           &lt;span style=&#34;color:#75715e&#34;&gt;# JavaScript 互操作層&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;pulldown-cmark&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.12&amp;#34;&lt;/span&gt;        &lt;span style=&#34;color:#75715e&#34;&gt;# 經過實戰驗證的 Markdown 解析器&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;web-sys&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.3&amp;#34;&lt;/span&gt;                &lt;span style=&#34;color:#75715e&#34;&gt;# Web API 綁定&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;serde&lt;/span&gt; = { &lt;span style=&#34;color:#a6e22e&#34;&gt;version&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;1.0&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#a6e22e&#34;&gt;features&lt;/span&gt; = [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;derive&amp;#34;&lt;/span&gt;] }
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;serde-wasm-bindgen&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.6&amp;#34;&lt;/span&gt;     &lt;span style=&#34;color:#75715e&#34;&gt;# Rust/JS 之間的資料序列化&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;console_error_panic_hook&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;0.1&amp;#34;&lt;/span&gt;  &lt;span style=&#34;color:#75715e&#34;&gt;# 瀏覽器中更好的錯誤訊息&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;專案結構&#34;&gt;專案結構&lt;/h3&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;wasm-markdown-editor/
├── Cargo.toml              # Rust 專案設定
├── index.html              # 主進入點
├── src/
│   ├── lib.rs             # WASM 進入點
│   ├── parser.rs          # Markdown 解析 + 統計邏輯
│   └── utils.rs           # Panic hook 和工具函式
├── www/
│   ├── index.js           # JavaScript 應用邏輯
│   └── styles.css         # 樣式
└── pkg/                   # 建置輸出
    ├── wasm_markdown_editor.js
    └── wasm_markdown_editor_bg.wasm&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;核心實作&#34;&gt;核心實作&lt;/h2&gt;
&lt;h3 id=&#34;將函式匯出到-javascript&#34;&gt;將函式匯出到 JavaScript&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; wasm_bindgen::prelude::&lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// WASM 模組載入時自動執行
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen(start)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    utils::set_panic_hook();  &lt;span style=&#34;color:#75715e&#34;&gt;// 更好的錯誤訊息
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 簡單的字串轉換
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;markdown_to_html&lt;/span&gt;(markdown: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; String {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    parser::parse_markdown(markdown)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 複雜結構 → JavaScript 物件
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[wasm_bindgen]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_statistics&lt;/span&gt;(text: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;JsValue&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; stats &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; parser::calculate_stats(text);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    serde_wasm_bindgen::to_value(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;stats).unwrap()
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;關鍵模式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;#[wasm_bindgen]&lt;/code&gt; 標記要匯出給 JS 的函式&lt;/li&gt;
&lt;li&gt;&lt;code&gt;#[wasm_bindgen(start)]&lt;/code&gt; 在模組初始化時自動執行&lt;/li&gt;
&lt;li&gt;簡單型別（str、數字、布林）自動轉換&lt;/li&gt;
&lt;li&gt;複雜型別需要 &lt;code&gt;serde-wasm-bindgen&lt;/code&gt; 進行序列化&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;markdown-解析&#34;&gt;Markdown 解析&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; pulldown_cmark::{html, Options, Parser};
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;parse_markdown&lt;/span&gt;(markdown: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; String {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; options &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Options::empty();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    options.insert(Options::&lt;span style=&#34;color:#66d9ef&#34;&gt;ENABLE_STRIKETHROUGH&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    options.insert(Options::&lt;span style=&#34;color:#66d9ef&#34;&gt;ENABLE_TABLES&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    options.insert(Options::&lt;span style=&#34;color:#66d9ef&#34;&gt;ENABLE_FOOTNOTES&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    options.insert(Options::&lt;span style=&#34;color:#66d9ef&#34;&gt;ENABLE_TASKLISTS&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; parser &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Parser::new_ext(markdown, options);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; html_output &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; String::new();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    html::push_html(&lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;mut&lt;/span&gt; html_output, parser);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    html_output
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;啟用的功能：刪除線、表格、註腳、任務清單、標題屬性。&lt;/p&gt;
&lt;h3 id=&#34;統計資訊計算&#34;&gt;統計資訊計算&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-rust&#34; data-lang=&#34;rust&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#[derive(Serialize)]&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;struct&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Statistics&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; characters: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; characters_no_spaces: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; words: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; lines: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; paragraphs: &lt;span style=&#34;color:#66d9ef&#34;&gt;usize&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; reading_time_minutes: &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;pub&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;fn&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;calculate_stats&lt;/span&gt;(text: &lt;span style=&#34;color:#66d9ef&#34;&gt;&amp;amp;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;str&lt;/span&gt;) -&amp;gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;Statistics&lt;/span&gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; words &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; text.split_whitespace().count();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; paragraphs &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; text
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .split(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;\n\n&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;&lt;/span&gt;)
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .filter(&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt;s&lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;s.trim().is_empty())
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        .count();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 平均閱讀速度：每分鐘 200 字
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; reading_time_minutes &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; (words &lt;span style=&#34;color:#66d9ef&#34;&gt;as&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;f64&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;200.0&lt;/span&gt;).ceil();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// ...
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;javascript-整合&#34;&gt;JavaScript 整合&lt;/h2&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-javascript&#34; data-lang=&#34;javascript&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;import&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;, {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;markdown_to_html&lt;/span&gt;,
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;get_statistics&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;} &lt;span style=&#34;color:#a6e22e&#34;&gt;from&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;../pkg/wasm_markdown_editor.js&amp;#39;&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;async&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;run&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 初始化 WASM 模組
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;await&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;init&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;// 現在可以使用 Rust 函式了
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;html&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;markdown_to_html&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;markdown&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;stats&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;get_statistics&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;text&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;// 效能優化：防抖動
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;let&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;debounceTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;null&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;const&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;DEBOUNCE_DELAY&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;300&lt;/span&gt;;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;function&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;handleInput&lt;/span&gt;() {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (&lt;span style=&#34;color:#a6e22e&#34;&gt;debounceTimer&lt;/span&gt;) &lt;span style=&#34;color:#a6e22e&#34;&gt;clearTimeout&lt;/span&gt;(&lt;span style=&#34;color:#a6e22e&#34;&gt;debounceTimer&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;updateStatistics&lt;/span&gt;();  &lt;span style=&#34;color:#75715e&#34;&gt;// 立即更新（快速）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    &lt;span style=&#34;color:#a6e22e&#34;&gt;debounceTimer&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;setTimeout&lt;/span&gt;(() =&amp;gt; {
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;updatePreview&lt;/span&gt;();   &lt;span style=&#34;color:#75715e&#34;&gt;// 防抖動（較重）
&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;        &lt;span style=&#34;color:#a6e22e&#34;&gt;saveToStorage&lt;/span&gt;();
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;    }, &lt;span style=&#34;color:#a6e22e&#34;&gt;DEBOUNCE_DELAY&lt;/span&gt;);
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;關鍵重點：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ES6 模組匯入 WASM&lt;/li&gt;
&lt;li&gt;呼叫 Rust 函式前必須先執行非同步的 &lt;code&gt;init()&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;防抖動避免過度渲染&lt;/li&gt;
&lt;li&gt;統計立即更新（便宜），預覽防抖動（昂貴）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;wasm-編譯深入解析&#34;&gt;WASM 編譯深入解析&lt;/h2&gt;
&lt;h3 id=&#34;編譯流程&#34;&gt;編譯流程&lt;/h3&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;1. Rust 原始碼 (lib.rs, parser.rs, utils.rs)
   ↓
2. rustc --target wasm32-unknown-unknown
   ↓
3. 原始 .wasm 二進位檔（WebAssembly 位元組碼）
   ↓
4. wasm-bindgen（產生 JS 膠水程式碼）
   ↓
5. wasm-opt（Binaryen 優化）
   ↓
6. 最終輸出：.wasm + .js + .d.ts&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;記憶體模型&#34;&gt;記憶體模型&lt;/h3&gt;
&lt;p&gt;WASM 使用&lt;strong&gt;線性記憶體&lt;/strong&gt;（單一連續區塊），JavaScript 和 Rust 透過這塊共享記憶體交換資料：&lt;/p&gt;

  &lt;div class=&#34;mermaid&#34;&gt;
    sequenceDiagram
    participant JS as JavaScript
    participant Mem as WASM 線性記憶體
    participant Rust as Rust

    JS-&gt;&gt;Mem: 1. 寫入字串
    JS-&gt;&gt;Rust: 2. 傳遞指標 + 長度
    Rust-&gt;&gt;Rust: 3. 處理資料
    Rust-&gt;&gt;Mem: 4. 寫入結果
    Rust-&gt;&gt;JS: 5. 回傳結果指標
    JS-&gt;&gt;Mem: 6. 讀取結果
    JS-&gt;&gt;Mem: 7. 釋放記憶體
  &lt;/div&gt;

&lt;p&gt;&lt;strong&gt;字串傳遞流程&lt;/strong&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;JS 字串寫入 WASM 線性記憶體&lt;/li&gt;
&lt;li&gt;傳遞指標和長度給 Rust 函式&lt;/li&gt;
&lt;li&gt;Rust 處理資料&lt;/li&gt;
&lt;li&gt;Rust 將結果寫入記憶體&lt;/li&gt;
&lt;li&gt;回傳結果的指標給 JS&lt;/li&gt;
&lt;li&gt;JS 從記憶體讀取結果字串&lt;/li&gt;
&lt;li&gt;釋放不再需要的記憶體&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;型別轉換對照表&#34;&gt;型別轉換對照表&lt;/h3&gt;
&lt;table&gt;
  &lt;thead&gt;
      &lt;tr&gt;
          &lt;th&gt;Rust 型別&lt;/th&gt;
          &lt;th&gt;WASM 型別&lt;/th&gt;
          &lt;th&gt;JavaScript 型別&lt;/th&gt;
      &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;&amp;amp;str&lt;/code&gt;, &lt;code&gt;String&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;i32 (ptr) + i32 (len)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;string&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;i32&lt;/code&gt;, &lt;code&gt;u32&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;i32&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;f64&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;f64&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;number&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;bool&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;i32 (0 或 1)&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;boolean&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;&lt;code&gt;JsValue&lt;/code&gt;&lt;/td&gt;
          &lt;td&gt;externref&lt;/td&gt;
          &lt;td&gt;any&lt;/td&gt;
      &lt;/tr&gt;
      &lt;tr&gt;
          &lt;td&gt;可序列化 struct&lt;/td&gt;
          &lt;td&gt;externref&lt;/td&gt;
          &lt;td&gt;&lt;code&gt;object&lt;/code&gt;&lt;/td&gt;
      &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;
&lt;h2 id=&#34;建置與效能&#34;&gt;建置與效能&lt;/h2&gt;
&lt;h3 id=&#34;建置指令&#34;&gt;建置指令&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 安裝 wasm-pack（只需一次）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cargo install wasm-pack
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 建置 WASM 模組&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wasm-pack build --target web
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 執行 Rust 單元測試&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cargo test
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 在瀏覽器中執行 WASM 測試&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;wasm-pack test --headless --firefox&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h3 id=&#34;建置輸出&#34;&gt;建置輸出&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;WASM 套件&lt;/strong&gt;：222 KB（已優化）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;JS 膠水程式碼&lt;/strong&gt;：13 KB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;總下載量&lt;/strong&gt;：235 KB&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建置時間&lt;/strong&gt;：約 8 秒（增量）、約 13 秒（完整）&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;cargotoml-關鍵設定&#34;&gt;Cargo.toml 關鍵設定&lt;/h3&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-toml&#34; data-lang=&#34;toml&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;lib&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;crate-type&lt;/span&gt; = [&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;cdylib&amp;#34;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;rlib&amp;#34;&lt;/span&gt;]  &lt;span style=&#34;color:#75715e&#34;&gt;# WASM 編譯必需&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;[&lt;span style=&#34;color:#a6e22e&#34;&gt;profile&lt;/span&gt;.&lt;span style=&#34;color:#a6e22e&#34;&gt;release&lt;/span&gt;]
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;opt-level&lt;/span&gt; = &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;s&amp;#34;&lt;/span&gt;    &lt;span style=&#34;color:#75715e&#34;&gt;# 優化檔案大小（而非速度）&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#a6e22e&#34;&gt;lto&lt;/span&gt; = &lt;span style=&#34;color:#66d9ef&#34;&gt;true&lt;/span&gt;         &lt;span style=&#34;color:#75715e&#34;&gt;# 連結時優化，產生更小的套件&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;為什麼這些設定很重要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;cdylib&lt;/code&gt; = C 動態函式庫類型，WASM 必需&lt;/li&gt;
&lt;li&gt;&lt;code&gt;opt-level = &amp;quot;s&amp;quot;&lt;/code&gt; 產生的二進位檔比 &amp;ldquo;3&amp;rdquo; 小約 30%&lt;/li&gt;
&lt;li&gt;LTO 消除整個依賴樹中的死碼&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;遇到的問題與解決方案&#34;&gt;遇到的問題與解決方案&lt;/h2&gt;
&lt;h3 id=&#34;問題404-錯誤&#34;&gt;問題：404 錯誤&lt;/h3&gt;
&lt;p&gt;從 &lt;code&gt;www/&lt;/code&gt; 目錄提供服務時，瀏覽器無法存取 &lt;code&gt;../pkg/&lt;/code&gt;（在提供的目錄之外）。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;初始嘗試&lt;/strong&gt;：從 &lt;code&gt;www/&lt;/code&gt; 目錄提供服務&lt;/p&gt;

  &lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;http://localhost:8080/  → www/index.html
http://localhost:8080/pkg/...  → 404 錯誤&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;解決方案&lt;/strong&gt;：在專案根目錄建立 &lt;code&gt;index.html&lt;/code&gt;&lt;/p&gt;

  &lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;-webkit-text-size-adjust:none;&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 從專案根目錄提供服務，而非 www/&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;cd wasm-markdown-editor
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;python -m http.server &lt;span style=&#34;color:#ae81ff&#34;&gt;8080&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span style=&#34;display:flex;&#34;&gt;&lt;span&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# 存取 http://localhost:8080&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;h2 id=&#34;實作的功能&#34;&gt;實作的功能&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;✅ 帶防抖動的即時預覽&lt;/li&gt;
&lt;li&gt;✅ 即時統計（字數、字元數、閱讀時間）&lt;/li&gt;
&lt;li&gt;✅ LocalStorage 自動儲存&lt;/li&gt;
&lt;li&gt;✅ 帶內嵌 CSS 的 HTML 匯出&lt;/li&gt;
&lt;li&gt;✅ 範例 Markdown 載入器&lt;/li&gt;
&lt;li&gt;✅ 鍵盤快捷鍵（Ctrl+S、Ctrl+K）&lt;/li&gt;
&lt;li&gt;✅ 響應式分割視窗佈局&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;學習成果&#34;&gt;學習成果&lt;/h2&gt;
&lt;h3 id=&#34;wasm-特定技能&#34;&gt;WASM 特定技能&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;✅ 理解 &lt;code&gt;cdylib&lt;/code&gt; crate 類型及其作用&lt;/li&gt;
&lt;li&gt;✅ 使用 &lt;code&gt;#[wasm_bindgen]&lt;/code&gt; 屬性匯出給 JS&lt;/li&gt;
&lt;li&gt;✅ 管理 Rust/JavaScript 邊界的記憶體&lt;/li&gt;
&lt;li&gt;✅ 型別轉換（簡單型別 vs. 複雜結構）&lt;/li&gt;
&lt;li&gt;✅ WASM 模組初始化模式&lt;/li&gt;
&lt;li&gt;✅ 在瀏覽器 DevTools 中除錯 WASM&lt;/li&gt;
&lt;li&gt;✅ 套件大小優化技術&lt;/li&gt;
&lt;li&gt;✅ 建置工具（&lt;code&gt;wasm-pack&lt;/code&gt;、&lt;code&gt;wasm-bindgen&lt;/code&gt;）&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;什麼時候該用-wasm&#34;&gt;什麼時候該用 WASM？&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;適合的場景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;✅ 計算密集型操作（解析、圖像處理）&lt;/li&gt;
&lt;li&gt;✅ 想重用現有的 Rust 函式庫&lt;/li&gt;
&lt;li&gt;✅ 效能關鍵路徑&lt;/li&gt;
&lt;li&gt;✅ 套件大小可接受時&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;不太適合的場景&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;❌ 大量 DOM 操作（用 JS）&lt;/li&gt;
&lt;li&gt;❌ 微小的工具函式（開銷不值得）&lt;/li&gt;
&lt;li&gt;❌ 簡單的 CRUD 操作&lt;/li&gt;
&lt;li&gt;❌ 套件大小是關鍵考量時&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;與純-javascript-方案的比較&#34;&gt;與純 JavaScript 方案的比較&lt;/h2&gt;
&lt;p&gt;&lt;strong&gt;效能&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Markdown 解析：比 JS 替代方案快約 2-3 倍&lt;/li&gt;
&lt;li&gt;打字時沒有 GC 暫停&lt;/li&gt;
&lt;li&gt;可預測的記憶體使用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;套件大小&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;與流行的 JS 函式庫相當或更小&lt;/li&gt;
&lt;li&gt;markdown-it.js：約 320 KB&lt;/li&gt;
&lt;li&gt;我們的方案：&lt;strong&gt;235 KB&lt;/strong&gt;（包含解析器 + 統計）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;反思&#34;&gt;反思&lt;/h2&gt;
&lt;h3 id=&#34;順利的部分&#34;&gt;順利的部分&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;流暢的建置過程&lt;/strong&gt;：wasm-pack「直接就能用」&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;優秀的文件&lt;/strong&gt;：Rust WASM book 非常有價值&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;型別安全&lt;/strong&gt;：編譯時就能捕捉錯誤&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;效能&lt;/strong&gt;：解析明顯流暢&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;工具鏈&lt;/strong&gt;：自動產生的 TypeScript 定義很有幫助&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;克服的挑戰&#34;&gt;克服的挑戰&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;路徑解析&lt;/strong&gt;：404 錯誤需要理解 WASM 服務方式&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;記憶體模型&lt;/strong&gt;：理解線性記憶體花了一些時間&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;型別轉換&lt;/strong&gt;：學習何時用 JsValue vs. 簡單型別&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;非同步初始化&lt;/strong&gt;：理解 init() 的必要性&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;驚喜的發現&#34;&gt;驚喜的發現&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;套件大小&lt;/strong&gt;：比預期小（222 KB 含完整解析器！）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;建置速度&lt;/strong&gt;：增量建置很快（8 秒）&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;瀏覽器支援&lt;/strong&gt;：所有現代瀏覽器都能用，不需要 polyfill&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;開發體驗&lt;/strong&gt;：在 DevTools 中除錯 WASM 相當不錯&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;結論&#34;&gt;結論&lt;/h2&gt;
&lt;p&gt;這個專案成功填補了我 rust-52-projects 學習旅程中的一個主要缺口。它證明了 &lt;strong&gt;Rust + WASM 已經可以用於生產環境&lt;/strong&gt;的互動式 Web 應用程式，尤其是像解析這樣的計算密集型任務。&lt;/p&gt;
&lt;p&gt;Rust 的效能和安全性與 JavaScript 的普及性結合，創造了一個強大的開發模式。工具鏈（&lt;code&gt;wasm-pack&lt;/code&gt;、&lt;code&gt;wasm-bindgen&lt;/code&gt;）已經成熟到體驗流暢且高效的程度。&lt;/p&gt;
&lt;p&gt;這是一個很好的「第一個 WASM 專案」，在學習核心概念的同時建構出真正實用的東西。&lt;/p&gt;
&lt;h2 id=&#34;參考資源&#34;&gt;參考資源&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://rustwasm.github.io/docs/book/&#34;&gt;Rust and WebAssembly Book&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://rustwasm.github.io/wasm-bindgen/&#34;&gt;wasm-bindgen Guide&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/pulldown-cmark/&#34;&gt;pulldown-cmark Docs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://docs.rs/serde-wasm-bindgen/&#34;&gt;serde-wasm-bindgen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
    </item>
    
  </channel>
</rss>
